{"hashes": {"core.py": "77b3c02cbb92e291a1f6bc410117451e", "main.py": "3a900262f1b1295065b55b62a77e0366", "responder_rules.json": "78569b4aeedf32dd1c5b663ad2829d1a", "db\\database_manager.py": "ae1efdddc3112d7ef39f6c30aa8f672f", "db\\__init__.py": "70f3e4b4c1c2302418b1f8f861731437", "logs\\2025-04-08.log": "f1ce73fab93a75e0e418bbd9b9f9c1bb", "rules\\rules_manager.py": "5d48f04257dcfd7ad1ac556f3ab2e3d1", "rules\\__init__.py": "9c0dd26b306a1d9e17e631e3caee6b65", "telegram\\client_manager.py": "f6c9ab341a620f289df8dad02858b70e", "telegram\\message_handler.py": "92c1ad345b24ea07bad74c88aa2d19bb", "telegram\\__init__.py": "d78139a96c7cecafaa7993f7ea4ed15d", "ui\\account_management.py": "f44b210b3e3abc32ac9334523e345918", "ui\\analytics.py": "16d01bf7733bf9a0eb3e83402e4d5769", "ui\\auto_responder.py": "cc7ba031e9b203810f823f3f1f4aa747", "ui\\main_menu.py": "8eaf99394c478d1f525c09cfdd2d6e40", "ui\\status.py": "2745bf6a147b446c9dc93c52f39b718c", "ui\\task_scheduling.py": "d8390b41a3d36370b58f0d745234f2a7", "ui\\work_cycle.py": "bf403ab81959856a42aeae44c6480c37", "ui\\__init__.py": "99227c63b436fa24f54874c19e0b35b3", "utils\\helpers.py": "8b0bb221c0e37e4b4ebb439f0b001cf8", "utils\\__init__.py": "48318b20608a173e2e3bc85326537d51"}, "contents": {"core.py": "# core.py\nclass UnlimitedLoginSystem:\n    def __init__(self):\n        pass # Inisialisasi akan dilakukan di main.py\n\n    async def shutdown(self):\n        pass # Shutdown akan dilakukan di main.py\n\n    async def run_responder(self):\n        \"\"\"Placeholder for background responder tasks\"\"\"\n        pass", "main.py": "# main.py\nimport asyncio\nimport logging\nimport signal\n\nfrom core import UnlimitedLoginSystem\nfrom db.database_manager import DatabaseManager\nfrom telegram.client_manager import ClientManager\nfrom rules.rules_manager import RulesManager\nfrom telegram.message_handler import MessageHandler\nfrom ui import MainMenu, AccountManagement, AutoResponderMenu, TaskSchedulingMenu, WorkCycleMenu, AnalyticsMenu, StatusMenu\nfrom utils.helpers import setup_logging\n\nasync def main():\n    setup_logging()  # Inisialisasi logging\n\n    # Inisialisasi sistem\n    db_manager = DatabaseManager()\n    client_manager = ClientManager()\n    rules_manager = RulesManager()\n    message_handler = MessageHandler(rules_manager)\n    system = UnlimitedLoginSystem() # Meskipun minimal, instance tetap dibuat\n\n    # Membuat instance dari setiap menu UI\n    account_manager = AccountManagement(db_manager, client_manager)\n    auto_responder_menu = AutoResponderMenu(rules_manager, client_manager, message_handler, db_manager)\n    task_scheduling_menu = TaskSchedulingMenu()\n    work_cycle_menu = WorkCycleMenu()\n    analytics_menu = AnalyticsMenu(db_manager, client_manager)\n    status_menu = StatusMenu(db_manager, client_manager)\n\n    # Membuat instance dari MainMenu dan memberikan dependensi\n    ui = MainMenu(account_manager, auto_responder_menu, task_scheduling_menu,\n                  work_cycle_menu, analytics_menu, status_menu)\n\n    loop = asyncio.get_event_loop()\n\n    async def shutdown():\n        await client_manager.disconnect_all_clients()\n        db_manager._close_connection()\n        logging.info(\"Program shutdown complete\")\n\n    def shutdown_handler(signame):\n        logging.info(f\"Received signal {signame}. Shutting down...\")\n        asyncio.create_task(shutdown())\n        loop.stop()\n\n    for signame in ('SIGINT', 'SIGTERM'):\n        try:\n            loop.add_signal_handler(getattr(signal, signame), lambda: shutdown_handler(signame))\n        except NotImplementedError:\n            pass\n\n    try:\n        await ui.display_main_menu()\n    except asyncio.CancelledError:\n        logging.info(\"Program canceled\")\n    except KeyboardInterrupt:\n        logging.info(\"Program interrupted by user\")\n    except Exception as e:\n        logging.error(f\"Unexpected error: {str(e)}\", exc_info=True)\n    finally:\n        await shutdown()\n        logging.info(\"Program shutdown complete\")\n\nif __name__ == \"__main__\":\n    try:\n        asyncio.run(main())\n    except KeyboardInterrupt:\n        logging.info(\"Program interrupted by user\")\n    except Exception as e:\n        logging.error(f\"Fatal error: {str(e)}\", exc_info=True)", "responder_rules.json": "{\n    \"1\": {\n        \"keyword\": \"notifikasi\",\n        \"responses\": [\n            \"Dulu cuma penasaran, sekarang malah jadi penghasilan tetap tiap minggu.\",\n            \"Udah beberapa kali narik profit, semua masuk lancar tanpa kendala.\",\n            \"Investasi pertama yang bener-bener kasih hasil nyata tanpa ribet.\",\n            \"Pokoknya puas banget! JTrade bukan kaleng-kaleng!\"\n        ],\n        \"private_only\": false\n    }\n}", "db\\database_manager.py": "# db/database_manager.py\nimport os\nimport sqlite3\nimport logging\nimport time\n\nclass DatabaseManager:\n    def __init__(self, db_path='accounts/accounts.db'):\n        self.db_path = db_path\n        self._setup_folders()\n        self.conn = None\n        self.cursor = None\n        self._setup_database()\n    \n    def _setup_folders(self):\n        os.makedirs('accounts', exist_ok=True)\n    \n    def _setup_database(self):\n        max_retries = 3\n        retry_delay = 1\n        for attempt in range(max_retries):\n            try:\n                self._close_connection()\n                self.conn = sqlite3.connect(self.db_path)\n                self.cursor = self.conn.cursor()\n                \n                # Cek apakah tabel sudah ada\n                self.cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name='accounts'\")\n                table_exists = self.cursor.fetchone()\n                \n                if not table_exists:\n                    # Buat tabel baru dengan id sebagai PRIMARY KEY autoincrement\n                    self.cursor.execute('''CREATE TABLE accounts(\n                        id INTEGER PRIMARY KEY AUTOINCREMENT,\n                        api_id INTEGER NOT NULL, \n                        api_hash TEXT, \n                        phone TEXT UNIQUE, \n                        twofa TEXT, \n                        user_id INTEGER, \n                        username TEXT, \n                        name TEXT)''')\n                else:\n                    # Cek struktur tabel yang ada\n                    self.cursor.execute(\"PRAGMA table_info(accounts)\")\n                    columns = [column[1] for column in self.cursor.fetchall()]\n                    \n                    # Jika tabel lama (tanpa kolom id), migrasi ke struktur baru\n                    if \"id\" not in columns:\n                        self.cursor.execute(\"ALTER TABLE accounts RENAME TO accounts_old\")\n                        self.cursor.execute('''CREATE TABLE accounts(\n                            id INTEGER PRIMARY KEY AUTOINCREMENT,\n                            api_id INTEGER NOT NULL, \n                            api_hash TEXT, \n                            phone TEXT UNIQUE, \n                            twofa TEXT, \n                            user_id INTEGER, \n                            username TEXT, \n                            name TEXT)''')\n                        self.cursor.execute('''INSERT INTO accounts \n                            (api_id, api_hash, phone, twofa, user_id, username, name)\n                            SELECT api_id, api_hash, phone, twofa, user_id, username, name \n                            FROM accounts_old''')\n                        self.cursor.execute(\"DROP TABLE accounts_old\")\n                        logging.info(\"Database berhasil dimigrasi ke struktur baru\")\n                \n                self.conn.commit()\n                logging.debug(\"Database connection established successfully\")\n                return\n            except sqlite3.Error as e:\n                logging.error(f\"Database connection error (attempt {attempt+1}/{max_retries}): {str(e)}\")\n                if attempt < max_retries - 1:\n                    time.sleep(retry_delay)\n                    retry_delay *= 2\n                else:\n                    logging.critical(\"Failed to connect to database after multiple attempts\")\n                    raise\n    \n    def _close_connection(self):\n        if self.conn:\n            try:\n                self.conn.close()\n                self.conn = None\n                self.cursor = None\n                logging.debug(\"Database connection closed\")\n            except sqlite3.Error as e:\n                logging.error(f\"Error closing database connection: {str(e)}\")\n    \n    def get_connection(self):\n        if not self.conn:\n            self._setup_database()\n        return self.conn, self.cursor\n    \n    def execute_query(self, query, params=(), fetch_all=False, commit=False):\n        max_retries = 3\n        retry_delay = 1\n        for attempt in range(max_retries):\n            try:\n                if not self.conn:\n                    self._setup_database()\n                self.cursor.execute(query, params)\n                if commit:\n                    self.conn.commit()\n                if fetch_all:\n                    return self.cursor.fetchall()\n                return True\n            except sqlite3.Error as e:\n                logging.error(f\"Database query error (attempt {attempt+1}/{max_retries}): {str(e)}\")\n                if \"database is locked\" in str(e) and attempt < max_retries - 1:\n                    time.sleep(retry_delay)\n                    retry_delay *= 2\n                    self._setup_database()\n                else:\n                    logging.error(\"Failed to execute query after retries\")\n                    raise\n        return False\n    \n    def get_all_accounts(self):\n        return self.execute_query(\"SELECT api_id, api_hash, phone, twofa, user_id, username, name FROM accounts\", fetch_all=True)\n    \n    def get_account_by_api_id(self, api_id):\n        accounts = self.execute_query(\"SELECT api_id, api_hash, phone, twofa, user_id, username, name FROM accounts WHERE api_id=?\", (api_id,), fetch_all=True)\n        return accounts[0] if accounts else None\n    \n    def add_account(self, api_id, api_hash, phone, twofa, user_id, username, name):\n        try:\n            result = self.execute_query(\n                \"INSERT OR IGNORE INTO accounts (api_id, api_hash, phone, twofa, user_id, username, name) VALUES (?,?,?,?,?,?,?)\",\n                (api_id, api_hash, phone, twofa, user_id, username, name),\n                commit=True\n            )\n            if self.cursor.rowcount == 0:\n                result = self.execute_query(\n                    \"UPDATE accounts SET api_id=?, api_hash=?, twofa=?, user_id=?, username=?, name=? WHERE phone=?\",\n                    (api_id, api_hash, twofa, user_id, username, name, phone),\n                    commit=True\n                )\n            return result\n        except sqlite3.IntegrityError as e:\n            logging.warning(f\"Constraint violation adding account {phone}: {str(e)}\")\n            return False\n    \n    def update_account(self, api_id, user_id, username, name):\n        return self.execute_query(\n            \"UPDATE accounts SET user_id=?, username=?, name=? WHERE api_id=?\", \n            (user_id, username, name, api_id), \n            commit=True\n        )\n    \n    def delete_account(self, api_id):\n        return self.execute_query(\"DELETE FROM accounts WHERE api_id=?\", (api_id,), commit=True)\n\n    def count_accounts(self):\n        result = self.execute_query(\"SELECT COUNT(*) FROM accounts\", fetch_all=True)\n        return result[0][0] if result else 0", "db\\__init__.py": "# db/__init__.py\nfrom .database_manager import DatabaseManager", "logs\\2025-04-08.log": "2025-04-08 03:13:55,581 - INFO - Program shutdown complete\n2025-04-08 03:13:55,581 - INFO - Program shutdown complete\n2025-04-08 03:30:45,465 - INFO - Connecting to 91.108.56.190:443/TcpFull...\n2025-04-08 03:30:45,507 - INFO - Connection to 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:30:45,878 - INFO - Disconnecting from 91.108.56.190:443/TcpFull...\n2025-04-08 03:30:45,879 - INFO - Disconnection from 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:30:45,886 - INFO - Connecting to 91.108.56.190:443/TcpFull...\n2025-04-08 03:30:45,927 - INFO - Connection to 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:30:46,392 - INFO - Disconnecting from 91.108.56.190:443/TcpFull...\n2025-04-08 03:30:46,393 - INFO - Disconnection from 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:30:46,400 - INFO - Connecting to 91.108.56.190:443/TcpFull...\n2025-04-08 03:30:46,437 - INFO - Connection to 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:30:46,904 - INFO - Disconnecting from 91.108.56.190:443/TcpFull...\n2025-04-08 03:30:46,905 - INFO - Disconnection from 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:30:46,913 - INFO - Connecting to 91.108.56.190:443/TcpFull...\n2025-04-08 03:30:46,955 - INFO - Connection to 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:30:47,415 - INFO - Disconnecting from 91.108.56.190:443/TcpFull...\n2025-04-08 03:30:47,417 - INFO - Disconnection from 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:30:47,425 - INFO - Connecting to 91.108.56.190:443/TcpFull...\n2025-04-08 03:30:47,467 - INFO - Connection to 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:30:47,927 - INFO - Disconnecting from 91.108.56.190:443/TcpFull...\n2025-04-08 03:30:47,928 - INFO - Disconnection from 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:30:47,936 - INFO - Connecting to 91.108.56.123:443/TcpFull...\n2025-04-08 03:30:47,977 - INFO - Connection to 91.108.56.123:443/TcpFull complete!\n2025-04-08 03:30:48,442 - INFO - Disconnecting from 91.108.56.123:443/TcpFull...\n2025-04-08 03:30:48,443 - INFO - Disconnection from 91.108.56.123:443/TcpFull complete!\n2025-04-08 03:30:48,449 - INFO - Connecting to 91.108.56.190:443/TcpFull...\n2025-04-08 03:30:48,540 - INFO - Connection to 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:30:48,948 - INFO - Disconnecting from 91.108.56.190:443/TcpFull...\n2025-04-08 03:30:48,949 - INFO - Disconnection from 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:30:48,953 - INFO - Connecting to 91.108.56.190:443/TcpFull...\n2025-04-08 03:30:49,051 - INFO - Connection to 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:30:49,460 - INFO - Disconnecting from 91.108.56.190:443/TcpFull...\n2025-04-08 03:30:49,461 - INFO - Disconnection from 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:30:49,465 - INFO - Connecting to 91.108.56.190:443/TcpFull...\n2025-04-08 03:30:49,563 - INFO - Connection to 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:30:49,975 - INFO - Disconnecting from 91.108.56.190:443/TcpFull...\n2025-04-08 03:30:49,977 - INFO - Disconnection from 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:30:49,985 - INFO - Connecting to 91.108.56.190:443/TcpFull...\n2025-04-08 03:30:50,016 - INFO - Connection to 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:30:50,589 - INFO - Disconnecting from 91.108.56.190:443/TcpFull...\n2025-04-08 03:30:50,590 - INFO - Disconnection from 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:30:50,599 - INFO - Connecting to 91.108.56.190:443/TcpFull...\n2025-04-08 03:30:50,690 - INFO - Connection to 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:30:51,139 - INFO - Disconnecting from 91.108.56.190:443/TcpFull...\n2025-04-08 03:30:51,141 - INFO - Disconnection from 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:30:51,148 - INFO - Connecting to 91.108.56.190:443/TcpFull...\n2025-04-08 03:30:51,202 - INFO - Connection to 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:30:51,614 - INFO - Disconnecting from 91.108.56.190:443/TcpFull...\n2025-04-08 03:30:51,616 - INFO - Disconnection from 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:30:51,622 - INFO - Connecting to 91.108.56.190:443/TcpFull...\n2025-04-08 03:30:51,657 - INFO - Connection to 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:30:52,126 - INFO - Disconnecting from 91.108.56.190:443/TcpFull...\n2025-04-08 03:30:52,127 - INFO - Disconnection from 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:30:52,133 - INFO - Connecting to 91.108.56.190:443/TcpFull...\n2025-04-08 03:30:52,177 - INFO - Connection to 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:30:52,637 - INFO - Disconnecting from 91.108.56.190:443/TcpFull...\n2025-04-08 03:30:52,638 - INFO - Disconnection from 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:30:52,645 - INFO - Connecting to 91.108.56.190:443/TcpFull...\n2025-04-08 03:30:52,738 - INFO - Connection to 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:30:53,147 - INFO - Disconnecting from 91.108.56.190:443/TcpFull...\n2025-04-08 03:30:53,148 - INFO - Disconnection from 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:30:53,152 - INFO - Connecting to 91.108.56.190:443/TcpFull...\n2025-04-08 03:30:53,249 - INFO - Connection to 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:30:53,662 - INFO - Disconnecting from 91.108.56.190:443/TcpFull...\n2025-04-08 03:30:53,664 - INFO - Disconnection from 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:30:53,670 - INFO - Connecting to 91.108.56.190:443/TcpFull...\n2025-04-08 03:30:53,707 - INFO - Connection to 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:30:54,071 - INFO - Disconnecting from 91.108.56.190:443/TcpFull...\n2025-04-08 03:30:54,073 - INFO - Disconnection from 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:30:54,081 - INFO - Connecting to 91.108.56.190:443/TcpFull...\n2025-04-08 03:30:54,171 - INFO - Connection to 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:30:54,582 - INFO - Disconnecting from 91.108.56.190:443/TcpFull...\n2025-04-08 03:30:54,583 - INFO - Disconnection from 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:30:54,590 - INFO - Connecting to 91.108.56.123:443/TcpFull...\n2025-04-08 03:30:54,626 - INFO - Connection to 91.108.56.123:443/TcpFull complete!\n2025-04-08 03:30:54,991 - INFO - Disconnecting from 91.108.56.123:443/TcpFull...\n2025-04-08 03:30:54,992 - INFO - Disconnection from 91.108.56.123:443/TcpFull complete!\n2025-04-08 03:30:54,997 - INFO - Connecting to 91.108.56.123:443/TcpFull...\n2025-04-08 03:30:55,037 - INFO - Connection to 91.108.56.123:443/TcpFull complete!\n2025-04-08 03:30:55,401 - INFO - Disconnecting from 91.108.56.123:443/TcpFull...\n2025-04-08 03:30:55,402 - INFO - Disconnection from 91.108.56.123:443/TcpFull complete!\n2025-04-08 03:30:55,406 - INFO - Connecting to 91.108.56.123:443/TcpFull...\n2025-04-08 03:30:55,437 - INFO - Connection to 91.108.56.123:443/TcpFull complete!\n2025-04-08 03:30:55,809 - INFO - Disconnecting from 91.108.56.123:443/TcpFull...\n2025-04-08 03:30:55,810 - INFO - Disconnection from 91.108.56.123:443/TcpFull complete!\n2025-04-08 03:30:55,816 - INFO - Connecting to 91.108.56.123:443/TcpFull...\n2025-04-08 03:30:55,856 - INFO - Connection to 91.108.56.123:443/TcpFull complete!\n2025-04-08 03:30:56,323 - INFO - Disconnecting from 91.108.56.123:443/TcpFull...\n2025-04-08 03:30:56,324 - INFO - Disconnection from 91.108.56.123:443/TcpFull complete!\n2025-04-08 03:30:56,330 - INFO - Connecting to 91.108.56.123:443/TcpFull...\n2025-04-08 03:30:56,367 - INFO - Connection to 91.108.56.123:443/TcpFull complete!\n2025-04-08 03:30:56,731 - INFO - Disconnecting from 91.108.56.123:443/TcpFull...\n2025-04-08 03:30:56,732 - INFO - Disconnection from 91.108.56.123:443/TcpFull complete!\n2025-04-08 03:30:56,737 - INFO - Connecting to 91.108.56.123:443/TcpFull...\n2025-04-08 03:30:56,777 - INFO - Connection to 91.108.56.123:443/TcpFull complete!\n2025-04-08 03:30:57,141 - INFO - Disconnecting from 91.108.56.123:443/TcpFull...\n2025-04-08 03:30:57,142 - INFO - Disconnection from 91.108.56.123:443/TcpFull complete!\n2025-04-08 03:30:57,145 - INFO - Connecting to 91.108.56.123:443/TcpFull...\n2025-04-08 03:30:57,176 - INFO - Connection to 91.108.56.123:443/TcpFull complete!\n2025-04-08 03:30:57,551 - INFO - Disconnecting from 91.108.56.123:443/TcpFull...\n2025-04-08 03:30:57,552 - INFO - Disconnection from 91.108.56.123:443/TcpFull complete!\n2025-04-08 03:30:57,556 - INFO - Connecting to 91.108.56.123:443/TcpFull...\n2025-04-08 03:30:57,597 - INFO - Connection to 91.108.56.123:443/TcpFull complete!\n2025-04-08 03:30:57,961 - INFO - Disconnecting from 91.108.56.123:443/TcpFull...\n2025-04-08 03:30:57,962 - INFO - Disconnection from 91.108.56.123:443/TcpFull complete!\n2025-04-08 03:30:57,967 - INFO - Connecting to 91.108.56.123:443/TcpFull...\n2025-04-08 03:30:58,006 - INFO - Connection to 91.108.56.123:443/TcpFull complete!\n2025-04-08 03:30:58,372 - INFO - Disconnecting from 91.108.56.123:443/TcpFull...\n2025-04-08 03:30:58,373 - INFO - Disconnection from 91.108.56.123:443/TcpFull complete!\n2025-04-08 03:30:58,378 - INFO - Connecting to 91.108.56.123:443/TcpFull...\n2025-04-08 03:30:58,406 - INFO - Connection to 91.108.56.123:443/TcpFull complete!\n2025-04-08 03:30:58,779 - INFO - Disconnecting from 91.108.56.123:443/TcpFull...\n2025-04-08 03:30:58,779 - INFO - Disconnection from 91.108.56.123:443/TcpFull complete!\n2025-04-08 03:30:58,783 - INFO - Connecting to 91.108.56.123:443/TcpFull...\n2025-04-08 03:30:58,881 - INFO - Connection to 91.108.56.123:443/TcpFull complete!\n2025-04-08 03:30:59,293 - INFO - Disconnecting from 91.108.56.123:443/TcpFull...\n2025-04-08 03:30:59,295 - INFO - Disconnection from 91.108.56.123:443/TcpFull complete!\n2025-04-08 03:30:59,303 - INFO - Connecting to 91.108.56.123:443/TcpFull...\n2025-04-08 03:30:59,393 - INFO - Connection to 91.108.56.123:443/TcpFull complete!\n2025-04-08 03:30:59,804 - INFO - Disconnecting from 91.108.56.123:443/TcpFull...\n2025-04-08 03:30:59,805 - INFO - Disconnection from 91.108.56.123:443/TcpFull complete!\n2025-04-08 03:30:59,810 - INFO - Connecting to 91.108.56.123:443/TcpFull...\n2025-04-08 03:30:59,846 - INFO - Connection to 91.108.56.123:443/TcpFull complete!\n2025-04-08 03:31:00,213 - INFO - Disconnecting from 91.108.56.123:443/TcpFull...\n2025-04-08 03:31:00,214 - INFO - Disconnection from 91.108.56.123:443/TcpFull complete!\n2025-04-08 03:31:00,218 - INFO - Connecting to 91.108.56.123:443/TcpFull...\n2025-04-08 03:31:00,257 - INFO - Connection to 91.108.56.123:443/TcpFull complete!\n2025-04-08 03:31:00,625 - INFO - Disconnecting from 91.108.56.123:443/TcpFull...\n2025-04-08 03:31:00,627 - INFO - Disconnection from 91.108.56.123:443/TcpFull complete!\n2025-04-08 03:31:00,632 - INFO - Connecting to 91.108.56.123:443/TcpFull...\n2025-04-08 03:31:00,725 - INFO - Connection to 91.108.56.123:443/TcpFull complete!\n2025-04-08 03:31:01,135 - INFO - Disconnecting from 91.108.56.123:443/TcpFull...\n2025-04-08 03:31:01,136 - INFO - Disconnection from 91.108.56.123:443/TcpFull complete!\n2025-04-08 03:31:01,140 - INFO - Connecting to 91.108.56.123:443/TcpFull...\n2025-04-08 03:31:01,166 - INFO - Connection to 91.108.56.123:443/TcpFull complete!\n2025-04-08 03:31:01,546 - INFO - Disconnecting from 91.108.56.123:443/TcpFull...\n2025-04-08 03:31:01,549 - INFO - Disconnection from 91.108.56.123:443/TcpFull complete!\n2025-04-08 03:31:01,556 - INFO - Connecting to 91.108.56.190:443/TcpFull...\n2025-04-08 03:31:01,646 - INFO - Connection to 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:31:02,059 - INFO - Disconnecting from 91.108.56.190:443/TcpFull...\n2025-04-08 03:31:02,061 - INFO - Disconnection from 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:31:02,068 - INFO - Connecting to 91.108.56.190:443/TcpFull...\n2025-04-08 03:31:02,158 - INFO - Connection to 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:31:02,571 - INFO - Disconnecting from 91.108.56.190:443/TcpFull...\n2025-04-08 03:31:02,572 - INFO - Disconnection from 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:31:02,578 - INFO - Connecting to 91.108.56.190:443/TcpFull...\n2025-04-08 03:31:02,607 - INFO - Connection to 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:31:02,980 - INFO - Disconnecting from 91.108.56.190:443/TcpFull...\n2025-04-08 03:31:02,982 - INFO - Disconnection from 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:31:02,988 - INFO - Connecting to 91.108.56.190:443/TcpFull...\n2025-04-08 03:31:03,027 - INFO - Connection to 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:31:03,492 - INFO - Disconnecting from 91.108.56.190:443/TcpFull...\n2025-04-08 03:31:03,495 - INFO - Disconnection from 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:31:03,501 - INFO - Connecting to 91.108.56.190:443/TcpFull...\n2025-04-08 03:31:03,593 - INFO - Connection to 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:31:04,002 - INFO - Disconnecting from 91.108.56.190:443/TcpFull...\n2025-04-08 03:31:04,003 - INFO - Disconnection from 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:31:04,008 - INFO - Connecting to 91.108.56.190:443/TcpFull...\n2025-04-08 03:31:04,047 - INFO - Connection to 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:31:04,517 - INFO - Disconnecting from 91.108.56.190:443/TcpFull...\n2025-04-08 03:31:04,519 - INFO - Disconnection from 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:31:04,526 - INFO - Connecting to 91.108.56.190:443/TcpFull...\n2025-04-08 03:31:04,618 - INFO - Connection to 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:31:05,029 - INFO - Disconnecting from 91.108.56.190:443/TcpFull...\n2025-04-08 03:31:05,031 - INFO - Disconnection from 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:31:05,038 - INFO - Connecting to 91.108.56.190:443/TcpFull...\n2025-04-08 03:31:05,128 - INFO - Connection to 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:31:05,540 - INFO - Disconnecting from 91.108.56.190:443/TcpFull...\n2025-04-08 03:31:05,542 - INFO - Disconnection from 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:31:05,547 - INFO - Connecting to 91.108.56.190:443/TcpFull...\n2025-04-08 03:31:05,587 - INFO - Connection to 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:31:05,947 - INFO - Disconnecting from 91.108.56.190:443/TcpFull...\n2025-04-08 03:31:05,947 - INFO - Disconnection from 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:31:05,950 - INFO - Connecting to 91.108.56.190:443/TcpFull...\n2025-04-08 03:31:06,050 - INFO - Connection to 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:31:06,461 - INFO - Disconnecting from 91.108.56.190:443/TcpFull...\n2025-04-08 03:31:06,464 - INFO - Disconnection from 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:31:06,471 - INFO - Connecting to 91.108.56.190:443/TcpFull...\n2025-04-08 03:31:06,563 - INFO - Connection to 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:31:06,972 - INFO - Disconnecting from 91.108.56.190:443/TcpFull...\n2025-04-08 03:31:06,973 - INFO - Disconnection from 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:31:06,979 - INFO - Connecting to 91.108.56.190:443/TcpFull...\n2025-04-08 03:31:07,017 - INFO - Connection to 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:31:07,381 - INFO - Disconnecting from 91.108.56.190:443/TcpFull...\n2025-04-08 03:31:07,383 - INFO - Disconnection from 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:31:07,388 - INFO - Connecting to 91.108.56.190:443/TcpFull...\n2025-04-08 03:31:07,427 - INFO - Connection to 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:31:07,790 - INFO - Disconnecting from 91.108.56.190:443/TcpFull...\n2025-04-08 03:31:07,790 - INFO - Disconnection from 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:31:07,795 - INFO - Connecting to 91.108.56.190:443/TcpFull...\n2025-04-08 03:31:07,837 - INFO - Connection to 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:31:08,201 - INFO - Disconnecting from 91.108.56.190:443/TcpFull...\n2025-04-08 03:31:08,202 - INFO - Disconnection from 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:31:08,208 - INFO - Connecting to 91.108.56.190:443/TcpFull...\n2025-04-08 03:31:08,246 - INFO - Connection to 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:31:08,609 - INFO - Disconnecting from 91.108.56.190:443/TcpFull...\n2025-04-08 03:31:08,610 - INFO - Disconnection from 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:31:08,616 - INFO - Connecting to 91.108.56.190:443/TcpFull...\n2025-04-08 03:31:08,712 - INFO - Connection to 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:31:09,123 - INFO - Disconnecting from 91.108.56.190:443/TcpFull...\n2025-04-08 03:31:09,124 - INFO - Disconnection from 91.108.56.190:443/TcpFull complete!\n2025-04-08 03:32:06,710 - INFO - Program canceled\n2025-04-08 03:32:06,711 - INFO - Program shutdown complete\n2025-04-08 03:32:06,712 - INFO - Program shutdown complete\n2025-04-08 03:32:06,714 - INFO - Program interrupted by user\n", "rules\\rules_manager.py": "# rules/rules_manager.py\nimport os\nimport logging\nimport json\nimport random\n\nclass RulesManager:\n    def __init__(self, rules_file='responder_rules.json'):\n        self.rules_file = rules_file\n        self.rules = {}\n        self._load_rules()\n    def _load_rules(self):\n        if os.path.exists(self.rules_file):\n            try:\n                with open(self.rules_file, 'r', encoding='utf-8') as f:\n                    self.rules = json.load(f)\n                self._migrate_rules_format()\n            except Exception as e:\n                logging.error(f\"Error loading rules: {str(e)}\")\n                self.rules = {}\n        else:\n            self.rules = {}\n            self._save_rules()\n    def _migrate_rules_format(self):\n        changed = False\n        for rule_id, rule in self.rules.items():\n            if isinstance(rule.get('response'), str):\n                rule['responses'] = [rule['response']]\n                del rule['response']\n                changed = True\n        if changed:\n            self._save_rules()\n            logging.info(\"Rules migrated to support multiple responses\")\n    def _save_rules(self):\n        try:\n            with open(self.rules_file, 'w', encoding='utf-8') as f:\n                json.dump(self.rules, f, indent=4)\n            logging.debug(\"Rules saved successfully\")\n            return True\n        except Exception as e:\n            logging.error(f\"Error saving rules: {str(e)}\")\n            return False\n    def get_all_rules(self):\n        return self.rules\n    def get_rule(self, rule_id):\n        return self.rules.get(rule_id)\n    def add_rule(self, keyword, response, private_only=False):\n        if not keyword.strip() or not response.strip():\n            return False, \"Kata kunci dan pesan balasan tidak boleh kosong!\"\n        rule_id = str(len(self.rules) + 1)\n        self.rules[rule_id] = {'keyword': keyword, 'responses': [response], 'private_only': private_only}\n        saved = self._save_rules()\n        return saved, f\"Aturan dengan ID {rule_id} berhasil ditambahkan!\" if saved else \"Gagal menyimpan aturan!\"\n    def update_rule(self, rule_id, keyword=None, response=None, private_only=None):\n        if rule_id not in self.rules:\n            return False, f\"Aturan dengan ID {rule_id} tidak ditemukan!\"\n        rule = self.rules[rule_id]\n        if keyword is not None and keyword.strip():\n            rule['keyword'] = keyword\n        if response is not None and response.strip():\n            if 'responses' not in rule:\n                rule['responses'] = []\n            rule['responses'].append(response)\n        if private_only is not None:\n            rule['private_only'] = private_only\n        saved = self._save_rules()\n        return saved, f\"Aturan dengan ID {rule_id} berhasil diperbarui!\" if saved else \"Gagal menyimpan aturan!\"\n    def delete_rule(self, rule_id):\n        if rule_id not in self.rules:\n            return False, f\"Aturan dengan ID {rule_id} tidak ditemukan!\"\n        del self.rules[rule_id]\n        saved = self._save_rules()\n        return saved, f\"Aturan dengan ID {rule_id} berhasil dihapus!\" if saved else \"Gagal menghapus aturan!\"\n    def delete_response(self, rule_id, response_index):\n        if rule_id not in self.rules:\n            return False, f\"Aturan dengan ID {rule_id} tidak ditemukan!\"\n        rule = self.rules[rule_id]\n        if 'responses' not in rule or not isinstance(rule['responses'], list):\n            return False, \"Format aturan tidak valid!\"\n        if response_index < 0 or response_index >= len(rule['responses']):\n            return False, f\"Indeks respons {response_index} tidak valid!\"\n        del rule['responses'][response_index]\n        if not rule['responses']:\n            rule['responses'] = [\"Default response\"]\n        saved = self._save_rules()\n        return saved, f\"Respons pada indeks {response_index} berhasil dihapus!\" if saved else \"Gagal menghapus respons!\"\n    def get_random_response(self, rule_id):\n        rule = self.rules.get(rule_id)\n        if not rule:\n            return None\n        responses = rule.get('responses', [])\n        if not responses and 'response' in rule:\n            return rule['response']\n        if not responses:\n            return None\n        return random.choice(responses)\n    def export_rules(self, filename=\"responder_rules_export.json\"):\n        if not self.rules:\n            return False, \"Tidak ada aturan yang dapat diekspor.\"\n        try:\n            with open(filename, 'w', encoding='utf-8') as f:\n                json.dump(self.rules, f, indent=4)\n            return True, f\"Berhasil mengekspor {len(self.rules)} aturan ke {filename}\"\n        except Exception as e:\n            logging.error(f\"Gagal mengekspor aturan: {str(e)}\")\n            return False, f\"Gagal mengekspor aturan: {str(e)}\"\n    def import_rules(self, filename=\"responder_rules_export.json\", replace=False):\n        if not os.path.exists(filename):\n            return False, f\"File {filename} tidak ditemukan!\"\n        try:\n            with open(filename, 'r', encoding='utf-8') as f:\n                imported_rules = json.load(f)\n            if not imported_rules:\n                return False, \"Tidak ada aturan yang dapat diimpor.\"\n            for rule_id, rule in imported_rules.items():\n                if 'response' in rule and 'responses' not in rule:\n                    rule['responses'] = [rule['response']]\n                    del rule['response']\n            if replace:\n                self.rules = imported_rules\n            else:\n                highest_id = 0\n                for rule_id in self.rules:\n                    try:\n                        rule_id_int = int(rule_id)\n                        if rule_id_int > highest_id:\n                            highest_id = rule_id_int\n                    except ValueError:\n                        pass\n                for rule_id, rule in imported_rules.items():\n                    if rule_id not in self.rules:\n                        self.rules[rule_id] = rule\n                    else:\n                        highest_id += 1\n                        self.rules[str(highest_id)] = rule\n            saved = self._save_rules()\n            return saved, f\"Berhasil mengimpor aturan. Total aturan saat ini: {len(self.rules)}\"\n        except Exception as e:\n            logging.error(f\"Gagal mengimpor aturan: {str(e)}\")\n            return False, f\"Gagal mengimpor aturan: {str(e)}\"", "rules\\__init__.py": "# rules/__init__.py\nfrom .rules_manager import RulesManager", "telegram\\client_manager.py": "# telegram/client_manager.py\nimport os\nimport logging\n\nfrom telethon import TelegramClient\nfrom telethon.errors import SessionPasswordNeededError, RPCError\n\nclass ClientManager:\n    def __init__(self):\n        self.active_clients = {}\n        os.makedirs('session', exist_ok=True)\n    async def create_client(self, api_id, api_hash, phone, default_2fa=None):\n        client = None\n        try:\n            client = TelegramClient(f'session/{phone}', api_id, api_hash)\n            await client.connect()\n            return client\n        except Exception as e:\n            logging.error(f\"Error creating client for {phone}: {str(e)}\")\n            if client and client.is_connected():\n                await client.disconnect()\n            raise\n    async def authorize_client(self, client, phone, default_2fa=None, code_callback=None):\n        try:\n            if not await client.is_user_authorized():\n                try:\n                    await client.send_code_request(phone)\n                    code = await code_callback() if code_callback else input(\"Masukkan kode yang diterima: \")\n                    await client.sign_in(phone, code)\n                except SessionPasswordNeededError:\n                    if default_2fa:\n                        await client.sign_in(password=default_2fa)\n                    else:\n                        password = input(\"Masukkan password 2FA: \")\n                        await client.sign_in(password=password)\n            me = await client.get_me()\n            return me\n        except Exception as e:\n            logging.error(f\"Error authorizing client for {phone}: {str(e)}\")\n            raise\n    async def test_connection(self, client, phone):\n        try:\n            if not client.is_connected():\n                await client.connect()\n            is_authorized = await client.is_user_authorized()\n            return {'phone': phone, 'status': 'Berhasil' if is_authorized else 'Gagal', 'error': None}\n        except RPCError as e:\n            return {'phone': phone, 'status': 'Gagal', 'error': str(e)}\n        except Exception as e:\n            return {'phone': phone, 'status': 'Error', 'error': str(e)}\n    def add_active_client(self, phone, client):\n        self.active_clients[phone] = client\n    def remove_active_client(self, phone):\n        if phone in self.active_clients:\n            del self.active_clients[phone]\n    async def disconnect_client(self, phone):\n        if phone in self.active_clients:\n            client = self.active_clients[phone]\n            if client and client.is_connected():\n                await client.disconnect()\n            self.remove_active_client(phone)\n            return True\n        return False\n    async def disconnect_all_clients(self):\n        for phone, client in list(self.active_clients.items()):\n            try:\n                if client and client.is_connected():\n                    await client.disconnect()\n            except Exception as e:\n                logging.error(f\"Error disconnecting client {phone}: {str(e)}\")\n            finally:\n                self.remove_active_client(phone)", "telegram\\message_handler.py": "# telegram/message_handler.py\nimport asyncio\nimport logging\nimport time\nimport random\n\nfrom telethon import events\n\nclass MessageHandler:\n    def __init__(self, rules_manager):\n        self.rules_manager = rules_manager\n        self.message_queues = {}\n        self.handlers = {}\n        self.delays = {}\n        self.last_responses = {}\n        self.last_response_times = {}\n    def setup_handler(self, client, phone, delay_seconds=0.5):\n        self.delays[phone] = delay_seconds\n        self.last_responses[phone] = {}\n        self.last_response_times[phone] = time.time()\n        self.message_queues[phone] = asyncio.Queue()\n        @client.on(events.NewMessage)\n        async def handle_new_message(event):\n            try:\n                if not hasattr(event, 'message') or not hasattr(event.message, 'text'):\n                    return\n                message_text = event.message.text\n                if not message_text:\n                    return\n                is_private = event.is_private\n                should_respond = False\n                rule_matched = None\n                for rule_id, rule in self.rules_manager.get_all_rules().items():\n                    private_only = rule.get('private_only', False)\n                    if private_only and not is_private:\n                        continue\n                    if rule['keyword'].lower() in message_text.lower():\n                        should_respond = True\n                        rule_matched = rule_id\n                        all_responses = rule.get('responses', [])\n                        if not all_responses and 'response' in rule:\n                            all_responses = [rule['response']]\n                        if len(all_responses) <= 1:\n                            response_text = all_responses[0] if all_responses else \"\"\n                        else:\n                            recent_responses = self.last_responses.get(phone, {}).get(rule_id, [])\n                            available_responses = [r for r in all_responses if r not in recent_responses]\n                            if not available_responses:\n                                available_responses = all_responses\n                            response_text = random.choice(available_responses)\n                            if rule_id not in self.last_responses.get(phone, {}):\n                                self.last_responses[phone][rule_id] = []\n                            self.last_responses[phone][rule_id].append(response_text)\n                            if len(self.last_responses[phone][rule_id]) > 2:\n                                self.last_responses[phone][rule_id].pop(0)\n                        break\n                if should_respond and rule_matched and response_text:\n                    current_time = time.time()\n                    time_since_last = current_time - self.last_response_times.get(phone, 0)\n                    extra_delay = 0\n                    if time_since_last < 30:\n                        extra_delay = random.uniform(10, 40)\n                    await self.message_queues[phone].put({'event': event, 'response': response_text, 'rule_id': rule_matched, 'extra_delay': extra_delay})\n            except Exception as e:\n                logging.error(f\"Error handling message: {str(e)}\")\n        self.handlers[phone] = handle_new_message\n        asyncio.create_task(self._process_message_queue(phone))\n    async def _process_message_queue(self, phone):\n        if phone not in self.message_queues:\n            return\n        queue = self.message_queues[phone]\n        base_delay_seconds = self.delays.get(phone, 0.5)\n        while phone in self.message_queues:\n            try:\n                try:\n                    item = await asyncio.wait_for(queue.get(), timeout=1.0)\n                except asyncio.TimeoutError:\n                    continue\n                event = item['event']\n                response = item['response']\n                rule_id = item['rule_id']\n                extra_delay = item.get('extra_delay', 0)\n                delay_variation = random.uniform(0.5, 1.5)\n                actual_delay = base_delay_seconds * delay_variation + extra_delay\n                logging.info(f\"Phone {phone}: Waiting {actual_delay:.2f}s before responding (base: {base_delay_seconds:.2f}s, extra: {extra_delay:.2f}s)\")\n                await asyncio.sleep(actual_delay)\n                typing_duration = min(len(response) / 5, 10)\n                typing_duration *= random.uniform(0.8, 1.2)\n                async with event.client.action(event.chat_id, 'typing'):\n                    await asyncio.sleep(typing_duration)\n                await asyncio.sleep(0.5)\n                await event.respond(response)\n                logging.info(f\"Auto respond to {event.sender_id} with rule {rule_id} (delay: {actual_delay:.2f}s, typing: {typing_duration:.2f}s)\")\n                self.last_response_times[phone] = time.time()\n                queue.task_done()\n            except asyncio.CancelledError:\n                break\n            except Exception as e:\n                logging.error(f\"Error processing message queue: {str(e)}\")\n                await asyncio.sleep(1)\n    def remove_handler(self, phone):\n        if phone in self.handlers:\n            del self.handlers[phone]\n        if phone in self.message_queues:\n            del self.message_queues[phone]\n        if phone in self.delays:\n            del self.delays[phone]\n        if phone in self.last_responses:\n            del self.last_responses[phone]\n        if phone in self.last_response_times:\n            del self.last_response_times[phone]", "telegram\\__init__.py": "# telegram/__init__.py\nfrom .client_manager import ClientManager\nfrom .message_handler import MessageHandler", "ui\\account_management.py": "# ui/account_management.py\nimport asyncio\nimport logging\nimport json  # Tambahkan baris ini\n\nfrom aioconsole import ainput\nfrom prettytable import PrettyTable\n\nclass AccountManagement:\n    def __init__(self, db_manager, client_manager):\n        self.db_manager = db_manager\n        self.client_manager = client_manager\n\n    async def add_account(self):\n        \"\"\"UI for adding a new account\"\"\"\n        try:\n            api_id = await ainput(\"Masukkan API ID: \")\n            api_hash = await ainput(\"Masukkan API HASH: \")\n            phone = await ainput(\"Masukkan nomor telepon: \")\n\n            if not api_id.strip() or not api_hash.strip() or not phone.strip():\n                print(\"Semua field harus diisi!\")\n                return\n\n            client = await self.client_manager.create_client(int(api_id), api_hash, phone)\n\n            async def code_callback():\n                return await ainput(\"Masukkan kode yang diterima: \")\n\n            me = await self.client_manager.authorize_client(client, phone,\n                                                            default_2fa=\"Dgvt61zwe@\",\n                                                            code_callback=code_callback)\n\n            self.db_manager.add_account(api_id, api_hash, phone, \"Dgvt61zwe@\",\n                                     me.id, me.username, me.first_name)\n\n            print(f\"Akun {phone} berhasil ditambahkan!\")\n            await client.disconnect()\n        except Exception as e:\n            logging.error(f\"Gagal menambahkan akun: {str(e)}\")\n            print(f\"Gagal menambahkan akun: {str(e)}\")\n\n    def list_accounts(self):\n        \"\"\"UI for listing all accounts with pagination support\"\"\"\n        table = PrettyTable()\n        table.field_names = [\"API ID\", \"Phone\", \"User ID\", \"Username\", \"Name\"]\n\n        try:\n            accounts = self.db_manager.get_all_accounts()\n            if not accounts:\n                print(\"Tidak ada akun yang tersimpan.\")\n                return\n            for row in accounts:\n                table.add_row([row[0], row[2], row[4], row[5], row[6]])\n            print(table)\n        except Exception as e:\n            logging.error(f\"Gagal menampilkan tabel: {str(e)}\")\n            print(f\"Gagal menampilkan tabel: {str(e)}\")\n\n    async def test_connection(self):\n        \"\"\"UI for testing account connections with auto-fix for failed accounts\"\"\"\n        try:\n            api_id = await ainput(\"Masukkan API ID (kosongkan untuk semua): \")\n            accounts = []\n            if api_id.strip():\n                account = self.db_manager.get_account_by_api_id(api_id)\n                if account:\n                    accounts = [account]\n            else:\n                accounts = self.db_manager.get_all_accounts()\n            if not accounts:\n                print(\"Tidak ada akun yang ditemukan!\")\n                return\n            results = {}\n            failed_accounts = []\n            for account in accounts:\n                api_id, api_hash, phone = account[0], account[1], account[2]\n                client = await self.client_manager.create_client(api_id, api_hash, phone)\n                result = await self.client_manager.test_connection(client, phone)\n                results[api_id] = result\n                if result['status'] != 'Berhasil':\n                    failed_accounts.append(account)\n                else:\n                    await client.disconnect()\n            print(\"Hasil uji koneksi:\")\n            for api_id, info in results.items():\n                status = info['status']\n                phone = info['phone']\n                error = info['error']\n                print(f\"- {phone} (API ID: {api_id}): {status}\")\n                if error:\n                    print(f\"  Error: {error}\")\n            if failed_accounts:\n                fix_all = await ainput(\"\\nAda akun yang gagal. Perbaiki semua? (y/n): \")\n                if fix_all.lower() == 'y':\n                    for account in failed_accounts:\n                        await self._fix_failed_account(account)\n                else:\n                    for i, account in enumerate(failed_accounts, 1):\n                        print(f\"{i}. {account[2]} (API ID: {account[0]})\")\n                    choice = await ainput(\"Pilih nomor akun yang akan diperbaiki (0 untuk batal): \")\n                    if choice != '0':\n                        try:\n                            idx = int(choice) - 1\n                            if 0 <= idx < len(failed_accounts):\n                                await self._fix_failed_account(failed_accounts[idx])\n                            else:\n                                print(\"Pilihan tidak valid!\")\n                        except ValueError:\n                            print(\"Input harus berupa angka!\")\n        except Exception as e:\n            logging.error(f\"Error during connection test: {str(e)}\")\n            print(f\"Gagal melakukan uji koneksi: {str(e)}\")\n\n    async def _fix_failed_account(self, account):\n        \"\"\"Fix a failed account by requesting new code and saving session\"\"\"\n        try:\n            from telethon.errors import SessionPasswordNeededError\n            api_id, api_hash, phone, twofa = account[0], account[1], account[2], account[3]\n            print(f\"\\nMemperbaiki akun {phone}...\")\n            client = await self.client_manager.create_client(int(api_id), api_hash, phone)\n            if not await client.is_user_authorized():\n                try:\n                    await client.send_code_request(phone)\n                    code = await ainput(\"Masukkan kode Telegram yang diterima: \")\n                    try:\n                        await client.sign_in(phone, code)\n                    except SessionPasswordNeededError:\n                        if twofa:\n                            await client.sign_in(password=twofa)\n                        else:\n                            password = await ainput(\"Masukkan password 2FA: \")\n                            await client.sign_in(password=password)\n                            self.db_manager.execute_query(\n                                \"UPDATE accounts SET twofa=? WHERE api_id=?\",\n                                (password, api_id),\n                                commit=True\n                            )\n                    me = await client.get_me()\n                    self.db_manager.update_account(api_id, me.id, me.username, me.first_name)\n                    print(f\"Akun {phone} berhasil diperbaiki dan diperbarui!\")\n                except Exception as e:\n                    logging.error(f\"Gagal memperbaiki akun {phone}: {str(e)}\")\n                    print(f\"Gagal memperbaiki akun {phone}: {str(e)}\")\n            else:\n                print(f\"Akun {phone} sudah terotorisasi.\")\n                me = await client.get_me()\n                self.db_manager.update_account(api_id, me.id, me.username, me.first_name)\n                print(f\"Info akun {phone} berhasil diperbarui!\")\n            await client.disconnect()\n        except Exception as e:\n            logging.error(f\"Gagal memperbaiki akun: {str(e)}\")\n            print(f\"Gagal memperbaiki akun: {str(e)}\")\n\n    async def delete_account(self):\n        \"\"\"UI for deleting an account\"\"\"\n        try:\n            api_id = await ainput(\"Masukkan API ID: \")\n            if not api_id.strip():\n                print(\"API ID tidak boleh kosong!\")\n                return\n            result = self.db_manager.delete_account(api_id)\n            if result:\n                print(f\"Akun {api_id} berhasil dihapus!\")\n            else:\n                print(f\"Gagal menghapus akun {api_id}!\")\n        except Exception as e:\n            logging.error(f\"Gagal menghapus akun: {str(e)}\")\n            print(f\"Gagal menghapus akun: {str(e)}\")\n\n    async def update_account(self):\n        \"\"\"UI for updating account information\"\"\"\n        try:\n            api_id = await ainput(\"Masukkan API ID yang akan diupdate: \")\n            if not api_id.strip():\n                print(\"API ID tidak boleh kosong!\")\n                return\n            account = self.db_manager.get_account_by_api_id(api_id)\n            if not account:\n                print(f\"Akun dengan API ID {api_id} tidak ditemukan!\")\n                return\n            api_id, api_hash, phone = account[0], account[1], account[2]\n            client = await self.client_manager.create_client(int(api_id), api_hash, phone)\n            me = await self.client_manager.authorize_client(client, phone, default_2fa=\"Dgvt61zwe@\")\n            self.db_manager.update_account(api_id, me.id, me.username, me.first_name)\n            await client.disconnect()\n            print(f\"Akun {phone} berhasil diperbarui!\")\n        except Exception as e:\n            logging.error(f\"Gagal memperbarui akun: {str(e)}\")\n            print(f\"Gagal memperbarui akun: {str(e)}\")\n\n    async def export_accounts(self):\n        \"\"\"UI for exporting accounts with verification\"\"\"\n        try:\n            filename = await ainput(\"Masukkan nama file (default: accounts_export.json): \")\n            if not filename.strip():\n                filename = \"accounts_export.json\"\n\n            accounts = self.db_manager.get_all_accounts()\n            if not accounts:\n                print(\"Tidak ada akun untuk diekspor.\")\n                return\n\n            account_list = []\n            for row in accounts:\n                api_id, api_hash, phone, twofa, user_id, username, name = row\n                account_list.append({\n                    \"api_id\": api_id,\n                    \"api_hash\": api_hash,\n                    \"phone\": phone,\n                    \"twofa\": twofa,\n                    \"user_id\": user_id,\n                    \"username\": username,\n                    \"name\": name\n                })\n\n            total_accounts = self.db_manager.count_accounts()\n            if len(account_list) != total_accounts:\n                print(f\"PERINGATAN: Jumlah akun yang diekspor ({len(account_list)}) tidak sesuai dengan jumlah akun di database ({total_accounts})\")\n                proceed = await ainput(\"Tetap lanjutkan ekspor? (y/n): \")\n                if proceed.lower() != 'y':\n                    print(\"Export dibatalkan.\")\n                    return\n\n            with open(filename, 'w', encoding='utf-8') as f:\n                json.dump(account_list, f, indent=4)\n\n            print(f\"Berhasil mengekspor {len(account_list)} akun ke {filename}\")\n\n            try:\n                with open(filename, 'r', encoding='utf-8') as f:\n                    verified_accounts = json.load(f)\n                if len(verified_accounts) == len(account_list):\n                    print(\"Verifikasi file berhasil: Jumlah akun yang diekspor sesuai.\")\n                else:\n                    print(f\"PERINGATAN: Verifikasi file gagal! File berisi {len(verified_accounts)} akun, seharusnya {len(account_list)}.\")\n            except Exception as e:\n                print(f\"Gagal memverifikasi file ekspor: {str(e)}\")\n\n        except Exception as e:\n            logging.error(f\"Gagal mengekspor akun: {str(e)}\")\n            print(f\"Gagal mengekspor akun: {str(e)}\")\n\n    async def import_accounts(self):\n        \"\"\"UI for importing accounts with improved tracking\"\"\"\n        try:\n            import os\n            filename = await ainput(\"Masukkan nama file (default: accounts_export.json): \")\n            if not filename.strip():\n                filename = \"accounts_export.json\"\n            if not os.path.exists(filename):\n                print(f\"File {filename} tidak ditemukan!\")\n                return\n\n            with open(filename, 'r', encoding='utf-8') as f:\n                accounts = json.load(f)\n\n            if not accounts:\n                print(\"Tidak ada akun untuk diimpor.\")\n                return\n\n            accounts_before = self.db_manager.count_accounts()\n\n            success_count = 0\n            fail_count = 0\n            skip_count = 0\n\n            if isinstance(accounts, dict):\n                accounts_list = []\n                for api_id, account_data in accounts.items():\n                    account_data['api_id'] = api_id\n                    accounts_list.append(account_data)\n                accounts = accounts_list\n\n            processed_phones = set()\n\n            for account in accounts:\n                try:\n                    api_id = int(account[\"api_id\"]) if isinstance(account[\"api_id\"], str) else account[\"api_id\"]\n                    api_hash = account.get(\"api_hash\", \"\")\n                    phone = account.get(\"phone\", \"\")\n\n                    if not phone or phone in processed_phones:\n                        skip_count += 1\n                        logging.warning(f\"Melewati akun dengan phone {phone} (kosong atau duplikat)\")\n                        continue\n\n                    twofa = account.get(\"twofa\", \"Dgvt61zwe@\")\n                    user_id = account.get(\"user_id\", 0)\n                    username = account.get(\"username\", None)\n                    name = account.get(\"name\", \"auto\")\n\n                    result = self.db_manager.add_account(\n                        api_id, api_hash, phone, twofa,\n                        user_id, username, name\n                    )\n\n                    if result:\n                        success_count += 1\n                        processed_phones.add(phone)\n                    else:\n                        fail_count += 1\n                        logging.warning(f\"Gagal menambahkan akun {phone} ke database\")\n\n                except Exception as e:\n                    logging.error(f\"Gagal mengimpor akun {account.get('phone', 'unknown')}: {str(e)}\")\n                    print(f\"Gagal mengimpor akun {account.get('phone', 'unknown')}: {str(e)}\")\n                    fail_count += 1\n\n            accounts_after = self.db_manager.count_accounts()\n            actual_added = accounts_after - accounts_before\n\n            print(f\"\\nRingkasan import dari {filename}:\")\n            print(f\"Total akun dalam file: {len(accounts)}\")\n            print(f\"Berhasil diimpor: {success_count}\")\n            print(f\"Gagal diimpor: {fail_count}\")\n            print(f\"Dilewati (duplikat): {skip_count}\")\n            print(f\"Tambahan akun di database: {actual_added}\")\n            print(f\"\\nTotal akun dalam database: {accounts_after}\")\n\n        except Exception as e:\n            logging.error(f\"Gagal mengimpor akun: {str(e)}\")\n            print(f\"Gagal mengimpor akun: {str(e)}\")", "ui\\analytics.py": "# ui/analytics.py\nimport asyncio\nimport logging\nimport json\nimport csv\nimport os\nimport matplotlib.pyplot as plt\nfrom datetime import datetime, timedelta\nimport time\n\nfrom aioconsole import ainput\nfrom prettytable import PrettyTable\n\nclass AnalyticsMenu:\n    def __init__(self, db_manager, client_manager):\n        self.db_manager = db_manager\n        self.client_manager = client_manager\n        self.analytics_dir = 'analytics'\n        self.charts_dir = os.path.join(self.analytics_dir, 'charts')\n        self._setup_folders()\n        self.analytics_data = self._load_analytics_data()\n\n    def _setup_folders(self):\n        \"\"\"Set up necessary folders for analytics\"\"\"\n        os.makedirs(self.analytics_dir, exist_ok=True)\n        os.makedirs(self.charts_dir, exist_ok=True)\n\n    def _load_analytics_data(self):\n        \"\"\"Load previous analytics data if available\"\"\"\n        data_file = os.path.join(self.analytics_dir, 'analytics_history.json')\n        if os.path.exists(data_file):\n            try:\n                with open(data_file, 'r', encoding='utf-8') as f:\n                    return json.load(f)\n            except Exception as e:\n                logging.error(f\"Error loading analytics data: {str(e)}\")\n        \n        # Return empty data structure if file doesn't exist or has an error\n        return {\n            \"daily\": {},\n            \"weekly\": {},\n            \"monthly\": {},\n            \"last_updated\": None\n        }\n\n    def _save_analytics_data(self):\n        \"\"\"Save analytics data to file\"\"\"\n        data_file = os.path.join(self.analytics_dir, 'analytics_history.json')\n        try:\n            with open(data_file, 'w', encoding='utf-8') as f:\n                json.dump(self.analytics_data, f, indent=4)\n            return True\n        except Exception as e:\n            logging.error(f\"Error saving analytics data: {str(e)}\")\n            return False\n\n    def _collect_current_analytics(self):\n        \"\"\"Collect current analytics data from the system\"\"\"\n        timestamp = datetime.now().isoformat()\n        \n        # Get account statistics\n        accounts = self.db_manager.get_all_accounts()\n        account_count = len(accounts)\n        active_clients = len(self.client_manager.active_clients)\n        \n        # Collect additional metrics\n        data = {\n            \"timestamp\": timestamp,\n            \"total_accounts\": account_count,\n            \"active_clients\": active_clients,\n            \"system_uptime\": time.time() - psutil.boot_time() if psutil_available else 0,\n        }\n        \n        # Update history data\n        today = datetime.now().strftime('%Y-%m-%d')\n        current_week = datetime.now().strftime('%Y-W%W')\n        current_month = datetime.now().strftime('%Y-%m')\n        \n        # Daily data\n        if today not in self.analytics_data[\"daily\"]:\n            self.analytics_data[\"daily\"][today] = []\n        self.analytics_data[\"daily\"][today].append(data)\n        \n        # Weekly data\n        if current_week not in self.analytics_data[\"weekly\"]:\n            self.analytics_data[\"weekly\"][current_week] = []\n        self.analytics_data[\"weekly\"][current_week].append(data)\n        \n        # Monthly data\n        if current_month not in self.analytics_data[\"monthly\"]:\n            self.analytics_data[\"monthly\"][current_month] = []\n        self.analytics_data[\"monthly\"][current_month].append(data)\n        \n        # Update last updated timestamp\n        self.analytics_data[\"last_updated\"] = timestamp\n        \n        # Save data\n        self._save_analytics_data()\n        \n        return data\n\n    def _generate_chart(self, data_points, title, ylabel, filename):\n        \"\"\"Generate chart from data points\"\"\"\n        x_values = []\n        y_values = []\n        \n        for point in data_points:\n            if isinstance(point, dict):\n                # If data point is a dictionary with timestamp and value\n                try:\n                    timestamp = datetime.fromisoformat(point.get('timestamp', '')).strftime('%H:%M')\n                    value = point.get('total_accounts', 0)  # Change this to the field you want to plot\n                    x_values.append(timestamp)\n                    y_values.append(value)\n                except (ValueError, AttributeError):\n                    continue\n            elif isinstance(point, tuple) and len(point) == 2:\n                # If data point is a tuple of (label, value)\n                x_values.append(point[0])\n                y_values.append(point[1])\n        \n        if not x_values or not y_values:\n            return None\n            \n        # Create a chart\n        plt.figure(figsize=(10, 6))\n        plt.plot(x_values, y_values, marker='o')\n        plt.title(title)\n        plt.xlabel('Time')\n        plt.ylabel(ylabel)\n        plt.xticks(rotation=45)\n        plt.tight_layout()\n        \n        # Save chart\n        chart_path = os.path.join(self.charts_dir, filename)\n        plt.savefig(chart_path)\n        plt.close()\n        \n        return chart_path\n\n    async def export_analytics_menu(self):\n        \"\"\"UI for export analytics menu\"\"\"\n        while True:\n            print(\"\\nExport Analytics Menu\")\n            print(\"1. Collect Current Analytics\")\n            print(\"2. Export Daily Analytics\")\n            print(\"3. Export Weekly Analytics\")\n            print(\"4. Export Monthly Analytics\")\n            print(\"5. Generate Analytics Charts\")\n            print(\"6. View Analytics Dashboard\")\n            print(\"7. Kembali ke Menu Utama\")\n            choice = await ainput(\"Pilih menu: \")\n            \n            if choice == '1':\n                await self.collect_analytics()\n            elif choice == '2':\n                await self.export_daily_analytics()\n            elif choice == '3':\n                await self.export_weekly_analytics()\n            elif choice == '4':\n                await self.export_monthly_analytics()\n            elif choice == '5':\n                await self.generate_analytics_charts()\n            elif choice == '6':\n                await self.view_analytics_dashboard()\n            elif choice == '7':\n                break\n            else:\n                print(\"Pilihan tidak valid!\")\n\n    async def collect_analytics(self):\n        \"\"\"Collect current analytics data\"\"\"\n        try:\n            print(\"Mengumpulkan data analitik terbaru...\")\n            data = self._collect_current_analytics()\n            \n            print(\"\\nData berhasil dikumpulkan:\")\n            print(f\"Timestamp: {datetime.fromisoformat(data['timestamp']).strftime('%Y-%m-%d %H:%M:%S')}\")\n            print(f\"Total Akun: {data['total_accounts']}\")\n            print(f\"Klien Aktif: {data['active_clients']}\")\n            \n            print(\"\\nData telah disimpan.\")\n        except Exception as e:\n            logging.error(f\"Error collecting analytics: {str(e)}\")\n            print(f\"Gagal mengumpulkan data analitik: {str(e)}\")\n\n    async def export_daily_analytics(self):\n        \"\"\"Export daily analytics data to a JSON file\"\"\"\n        try:\n            # Collect current data before exporting\n            self._collect_current_analytics()\n            \n            today = datetime.now().strftime('%Y-%m-%d')\n            today_data = self.analytics_data[\"daily\"].get(today, [])\n            \n            if not today_data:\n                print(\"Tidak ada data harian untuk diekspor.\")\n                return\n            \n            # Prepare export data\n            export_data = {\n                \"date\": today,\n                \"data_points\": len(today_data),\n                \"analytics\": today_data,\n                \"summary\": {\n                    \"total_accounts\": today_data[-1][\"total_accounts\"] if today_data else 0,\n                    \"active_clients\": today_data[-1][\"active_clients\"] if today_data else 0,\n                    \"last_updated\": datetime.now().isoformat()\n                }\n            }\n            \n            # Get filename from user\n            filename = await ainput(\"Masukkan nama file untuk daily analytics (default: daily_analytics.json): \")\n            if not filename.strip():\n                filename = \"daily_analytics.json\"\n            \n            # Ensure .json extension\n            if not filename.lower().endswith('.json'):\n                filename += '.json'\n            \n            # Save to file\n            filepath = os.path.join(self.analytics_dir, filename)\n            with open(filepath, 'w', encoding='utf-8') as f:\n                json.dump(export_data, f, indent=4)\n            \n            print(f\"Daily analytics berhasil diekspor ke {filepath}.\")\n            \n            # Ask if CSV export is also needed\n            csv_export = await ainput(\"Ekspor juga sebagai CSV? (y/n): \")\n            if csv_export.lower() == 'y':\n                csv_filename = filename.replace('.json', '.csv')\n                csv_filepath = os.path.join(self.analytics_dir, csv_filename)\n                \n                with open(csv_filepath, 'w', newline='', encoding='utf-8') as f:\n                    writer = csv.writer(f)\n                    # Write header\n                    writer.writerow(['Timestamp', 'Total Accounts', 'Active Clients'])\n                    \n                    # Write data\n                    for point in today_data:\n                        writer.writerow([\n                            datetime.fromisoformat(point['timestamp']).strftime('%Y-%m-%d %H:%M:%S'),\n                            point['total_accounts'],\n                            point['active_clients']\n                        ])\n                \n                print(f\"Daily analytics berhasil diekspor ke CSV: {csv_filepath}\")\n        except Exception as e:\n            logging.error(f\"Gagal mengekspor daily analytics: {str(e)}\")\n            print(f\"Gagal mengekspor daily analytics: {str(e)}\")\n\n    async def export_weekly_analytics(self):\n        \"\"\"Export weekly analytics data to a JSON file\"\"\"\n        try:\n            # Collect current data before exporting\n            self._collect_current_analytics()\n            \n            current_week = datetime.now().strftime('%Y-W%W')\n            week_data = self.analytics_data[\"weekly\"].get(current_week, [])\n            \n            if not week_data:\n                print(\"Tidak ada data mingguan untuk diekspor.\")\n                return\n            \n            # Calculate daily averages\n            daily_data = {}\n            for point in week_data:\n                day = datetime.fromisoformat(point['timestamp']).strftime('%Y-%m-%d')\n                if day not in daily_data:\n                    daily_data[day] = {\n                        'total_accounts': [],\n                        'active_clients': []\n                    }\n                daily_data[day]['total_accounts'].append(point['total_accounts'])\n                daily_data[day]['active_clients'].append(point['active_clients'])\n            \n            daily_averages = {}\n            for day, metrics in daily_data.items():\n                daily_averages[day] = {\n                    'avg_total_accounts': sum(metrics['total_accounts']) / len(metrics['total_accounts']),\n                    'avg_active_clients': sum(metrics['active_clients']) / len(metrics['active_clients']),\n                    'max_total_accounts': max(metrics['total_accounts']),\n                    'max_active_clients': max(metrics['active_clients'])\n                }\n            \n            # Prepare export data\n            export_data = {\n                \"week\": current_week,\n                \"data_points\": len(week_data),\n                \"daily_averages\": daily_averages,\n                \"analytics\": week_data,\n                \"summary\": {\n                    \"total_accounts\": week_data[-1][\"total_accounts\"] if week_data else 0,\n                    \"active_clients\": week_data[-1][\"active_clients\"] if week_data else 0,\n                    \"last_updated\": datetime.now().isoformat()\n                }\n            }\n            \n            # Get filename from user\n            filename = await ainput(\"Masukkan nama file untuk weekly analytics (default: weekly_analytics.json): \")\n            if not filename.strip():\n                filename = \"weekly_analytics.json\"\n            \n            # Ensure .json extension\n            if not filename.lower().endswith('.json'):\n                filename += '.json'\n            \n            # Save to file\n            filepath = os.path.join(self.analytics_dir, filename)\n            with open(filepath, 'w', encoding='utf-8') as f:\n                json.dump(export_data, f, indent=4)\n            \n            print(f\"Weekly analytics berhasil diekspor ke {filepath}.\")\n        except Exception as e:\n            logging.error(f\"Gagal mengekspor weekly analytics: {str(e)}\")\n            print(f\"Gagal mengekspor weekly analytics: {str(e)}\")\n\n    async def export_monthly_analytics(self):\n        \"\"\"Export monthly analytics data to a JSON file\"\"\"\n        try:\n            # Collect current data before exporting\n            self._collect_current_analytics()\n            \n            current_month = datetime.now().strftime('%Y-%m')\n            month_data = self.analytics_data[\"monthly\"].get(current_month, [])\n            \n            if not month_data:\n                print(\"Tidak ada data bulanan untuk diekspor.\")\n                return\n            \n            # Calculate weekly averages\n            weekly_data = {}\n            for point in month_data:\n                date = datetime.fromisoformat(point['timestamp'])\n                week = date.strftime('%Y-W%W')\n                if week not in weekly_data:\n                    weekly_data[week] = {\n                        'total_accounts': [],\n                        'active_clients': []\n                    }\n                weekly_data[week]['total_accounts'].append(point['total_accounts'])\n                weekly_data[week]['active_clients'].append(point['active_clients'])\n            \n            weekly_averages = {}\n            for week, metrics in weekly_data.items():\n                weekly_averages[week] = {\n                    'avg_total_accounts': sum(metrics['total_accounts']) / len(metrics['total_accounts']),\n                    'avg_active_clients': sum(metrics['active_clients']) / len(metrics['active_clients']),\n                    'max_total_accounts': max(metrics['total_accounts']),\n                    'max_active_clients': max(metrics['active_clients'])\n                }\n            \n            # Prepare export data\n            export_data = {\n                \"month\": current_month,\n                \"data_points\": len(month_data),\n                \"weekly_averages\": weekly_averages,\n                \"analytics\": month_data,\n                \"summary\": {\n                    \"total_accounts\": month_data[-1][\"total_accounts\"] if month_data else 0,\n                    \"active_clients\": month_data[-1][\"active_clients\"] if month_data else 0,\n                    \"last_updated\": datetime.now().isoformat()\n                }\n            }\n            \n            # Get filename from user\n            filename = await ainput(\"Masukkan nama file untuk monthly analytics (default: monthly_analytics.json): \")\n            if not filename.strip():\n                filename = \"monthly_analytics.json\"\n            \n            # Ensure .json extension\n            if not filename.lower().endswith('.json'):\n                filename += '.json'\n            \n            # Save to file\n            filepath = os.path.join(self.analytics_dir, filename)\n            with open(filepath, 'w', encoding='utf-8') as f:\n                json.dump(export_data, f, indent=4)\n            \n            print(f\"Monthly analytics berhasil diekspor ke {filepath}.\")\n        except Exception as e:\n            logging.error(f\"Gagal mengekspor monthly analytics: {str(e)}\")\n            print(f\"Gagal mengekspor monthly analytics: {str(e)}\")\n\n    async def generate_analytics_charts(self):\n        \"\"\"Generate various analytics charts\"\"\"\n        try:\n            # Collect current data\n            self._collect_current_analytics()\n            \n            print(\"Generating analytics charts...\")\n            charts_generated = 0\n            \n            # Get daily data for today\n            today = datetime.now().strftime('%Y-%m-%d')\n            today_data = self.analytics_data[\"daily\"].get(today, [])\n            \n            if today_data:\n                # Generate daily account chart\n                chart_path = self._generate_chart(\n                    today_data,\n                    f\"Daily Account Statistics - {today}\",\n                    \"Number of Accounts\",\n                    f\"daily_accounts_{today}.png\"\n                )\n                if chart_path:\n                    print(f\"Generated daily account chart: {chart_path}\")\n                    charts_generated += 1\n            \n            # Get weekly data\n            current_week = datetime.now().strftime('%Y-W%W')\n            week_data = self.analytics_data[\"weekly\"].get(current_week, [])\n            \n            if week_data:\n                # Transform data for weekly chart - one point per day\n                daily_averages = {}\n                for point in week_data:\n                    day = datetime.fromisoformat(point['timestamp']).strftime('%Y-%m-%d')\n                    if day not in daily_averages:\n                        daily_averages[day] = {'total_accounts': [], 'active_clients': []}\n                    daily_averages[day]['total_accounts'].append(point['total_accounts'])\n                    daily_averages[day]['active_clients'].append(point['active_clients'])\n                \n                chart_data = []\n                for day, metrics in sorted(daily_averages.items()):\n                    chart_data.append((\n                        day,\n                        sum(metrics['total_accounts']) / len(metrics['total_accounts'])\n                    ))\n                \n                # Generate weekly account chart\n                chart_path = self._generate_chart(\n                    chart_data,\n                    f\"Weekly Account Statistics - {current_week}\",\n                    \"Average Number of Accounts\",\n                    f\"weekly_accounts_{current_week.replace(':', '_')}.png\"\n                )\n                if chart_path:\n                    print(f\"Generated weekly account chart: {chart_path}\")\n                    charts_generated += 1\n            \n            # Get monthly data\n            current_month = datetime.now().strftime('%Y-%m')\n            month_data = self.analytics_data[\"monthly\"].get(current_month, [])\n            \n            if month_data:\n                # Transform data for monthly chart - one point per week\n                weekly_averages = {}\n                for point in month_data:\n                    date = datetime.fromisoformat(point['timestamp'])\n                    week = date.strftime('%Y-W%W')\n                    if week not in weekly_averages:\n                        weekly_averages[week] = {'total_accounts': [], 'active_clients': []}\n                    weekly_averages[week]['total_accounts'].append(point['total_accounts'])\n                    weekly_averages[week]['active_clients'].append(point['active_clients'])\n                \n                chart_data = []\n                for week, metrics in sorted(weekly_averages.items()):\n                    chart_data.append((\n                        week,\n                        sum(metrics['total_accounts']) / len(metrics['total_accounts'])\n                    ))\n                \n                # Generate monthly account chart\n                chart_path = self._generate_chart(\n                    chart_data,\n                    f\"Monthly Account Statistics - {current_month}\",\n                    \"Average Number of Accounts\",\n                    f\"monthly_accounts_{current_month}.png\"\n                )\n                if chart_path:\n                    print(f\"Generated monthly account chart: {chart_path}\")\n                    charts_generated += 1\n            \n            if charts_generated == 0:\n                print(\"Tidak ada data yang cukup untuk menghasilkan grafik.\")\n            else:\n                print(f\"Berhasil menghasilkan {charts_generated} grafik di folder {self.charts_dir}\")\n        except Exception as e:\n            logging.error(f\"Error generating analytics charts: {str(e)}\")\n            print(f\"Gagal menghasilkan grafik analitik: {str(e)}\")\n\n    async def view_analytics_dashboard(self):\n        \"\"\"View a simple analytics dashboard in the console\"\"\"\n        try:\n            # Collect current data\n            current_data = self._collect_current_analytics()\n            \n            print(\"\\n==== ANALYTICS DASHBOARD ====\")\n            print(f\"Timestamp: {datetime.fromisoformat(current_data['timestamp']).strftime('%Y-%m-%d %H:%M:%S')}\")\n            print(f\"Total Accounts: {current_data['total_accounts']}\")\n            print(f\"Active Clients: {current_data['active_clients']}\")\n            \n            # Show historical data\n            today = datetime.now().strftime('%Y-%m-%d')\n            yesterday = (datetime.now() - timedelta(days=1)).strftime('%Y-%m-%d')\n            \n            today_data = self.analytics_data[\"daily\"].get(today, [])\n            yesterday_data = self.analytics_data[\"daily\"].get(yesterday, [])\n            \n            if today_data:\n                # Calculate day statistics\n                today_start = None\n                for point in today_data:\n                    if not today_start:\n                        today_start = point\n                \n                if today_start:\n                    print(\"\\n--- Today's Changes ---\")\n                    account_change = current_data['total_accounts'] - today_start['total_accounts']\n                    print(f\"Account Change: {account_change:+d}\")\n                    client_change = current_data['active_clients'] - today_start['active_clients']\n                    print(f\"Active Client Change: {client_change:+d}\")\n            \n            if yesterday_data:\n                # Get the last data point from yesterday\n                yesterday_end = yesterday_data[-1]\n                print(\"\\n--- Yesterday vs Today ---\")\n                account_change = current_data['total_accounts'] - yesterday_end['total_accounts']\n                print(f\"Account Change: {account_change:+d}\")\n                client_change = current_data['active_clients'] - yesterday_end['active_clients']\n                print(f\"Active Client Change: {client_change:+d}\")\n            \n            # Show recent charts if available\n            print(\"\\n--- Recent Charts ---\")\n            chart_files = [f for f in os.listdir(self.charts_dir) if f.endswith('.png')]\n            \n            if chart_files:\n                for chart_file in sorted(chart_files, reverse=True)[:3]:  # Show 3 most recent charts\n                    print(f\"- {chart_file} ({os.path.join(self.charts_dir, chart_file)})\")\n            else:\n                print(\"No charts available. Generate charts first.\")\n            \n            print(\"\\n=============================\")\n        except Exception as e:\n            logging.error(f\"Error displaying analytics dashboard: {str(e)}\")\n            print(f\"Gagal menampilkan dasbor analitik: {str(e)}\")\n\n\n# Try to import psutil for system metrics, but don't fail if it's not available\ntry:\n    import psutil\n    psutil_available = True\nexcept ImportError:\n    psutil_available = False", "ui\\auto_responder.py": "# ui/auto_responder.py\nimport asyncio\nimport logging\nimport random\n\nfrom aioconsole import ainput\n\nclass AutoResponderMenu:\n    def __init__(self, rules_manager, client_manager, message_handler, db_manager):\n        self.rules_manager = rules_manager\n        self.client_manager = client_manager\n        self.message_handler = message_handler\n        self.db_manager = db_manager\n\n    async def auto_responder_menu(self):\n        \"\"\"UI for auto responder menu\"\"\"\n        while True:\n            print(\"\\nAuto Responder Menu\")\n            print(\"1. Lihat Semua Aturan\")\n            print(\"2. Tambah Aturan Baru\")\n            print(\"3. Hapus Aturan\")\n            print(\"4. Edit Aturan\")\n            print(\"5. Tambah Respons Alternatif\")\n            print(\"6. Hapus Respons Alternatif\")\n            print(\"7. Mulai Auto Responder\")\n            print(\"8. Hentikan Auto Responder\")\n            print(\"9. Export Aturan\")\n            print(\"10. Import Aturan\")\n            print(\"11. Kembali ke Menu Utama\")\n\n            choice = await ainput(\"Pilih menu: \")\n\n            if choice == '1':\n                self.list_rules()\n            elif choice == '2':\n                await self.add_rule()\n            elif choice == '3':\n                await self.delete_rule()\n            elif choice == '4':\n                await self.edit_rule()\n            elif choice == '5':\n                await self.add_alternative_response()\n            elif choice == '6':\n                await self.delete_alternative_response()\n            elif choice == '7':\n                await self.start_responder()\n            elif choice == '8':\n                await self.stop_responder()\n            elif choice == '9':\n                await self.export_rules()\n            elif choice == '10':\n                await self.import_rules()\n            elif choice == '11':\n                break  # Keluar dari loop menu auto responder\n            else:\n                print(\"Pilihan tidak valid!\")\n\n    def list_rules(self):\n        \"\"\"List all rules with responses\"\"\"\n        rules = self.rules_manager.get_all_rules()\n        if not rules:\n            print(\"Tidak ada aturan auto responder yang tersimpan.\")\n            return\n        print(\"\\nDaftar Aturan Auto Responder:\")\n        for rule_id, rule in rules.items():\n            print(f\"ID: {rule_id}\")\n            print(f\"  Kata Kunci: {rule['keyword']}\")\n            responses = rule.get('responses', [])\n            if not responses and 'response' in rule:\n                responses = [rule['response']]\n            print(f\"  Jumlah Respons: {len(responses)}\")\n            for i, response in enumerate(responses):\n                print(f\"    [{i}] {response}\")\n            print(f\"  Hanya Private Chat: {'Ya' if rule.get('private_only', False) else 'Tidak'}\")\n            print()\n\n    async def add_rule(self):\n        \"\"\"UI for adding a new rule\"\"\"\n        keyword = await ainput(\"Masukkan kata kunci/pola: \")\n        response = await ainput(\"Masukkan pesan balasan: \")\n        private_only = await ainput(\"Hanya untuk private chat? (y/n): \")\n        success, message = self.rules_manager.add_rule(\n            keyword, response, private_only.lower() == 'y'\n        )\n        print(message)\n\n    async def delete_rule(self):\n        \"\"\"UI for deleting a rule\"\"\"\n        self.list_rules()\n        rule_id = await ainput(\"Masukkan ID aturan yang akan dihapus: \")\n        success, message = self.rules_manager.delete_rule(rule_id)\n        print(message)\n\n    async def edit_rule(self):\n        \"\"\"UI for editing a rule\"\"\"\n        self.list_rules()\n        rule_id = await ainput(\"Masukkan ID aturan yang akan diedit: \")\n        rule = self.rules_manager.get_rule(rule_id)\n        if not rule:\n            print(f\"Aturan dengan ID {rule_id} tidak ditemukan!\")\n            return\n        print(f\"\\nNilai saat ini:\")\n        print(f\"Kata Kunci: {rule['keyword']}\")\n        responses = rule.get('responses', [])\n        if not responses and 'response' in rule:\n            response_main = rule['response']\n        else:\n            response_main = responses[0] if responses else \"\"\n        print(f\"Pesan Balasan Utama: {response_main}\")\n        print(f\"Hanya Private Chat: {'Ya' if rule.get('private_only', False) else 'Tidak'}\")\n        print(\"\\nMasukkan nilai baru (kosongkan untuk menggunakan nilai saat ini):\")\n        new_keyword = await ainput(\"Kata kunci baru: \")\n        new_private_only = await ainput(\"Hanya private chat? (y/n): \")\n        private_only = None\n        if new_private_only.strip():\n            private_only = new_private_only.lower() == 'y'\n        success, message = self.rules_manager.update_rule(\n            rule_id,\n            keyword=new_keyword if new_keyword.strip() else None,\n            private_only=private_only\n        )\n        print(message)\n\n    async def add_alternative_response(self):\n        \"\"\"UI for adding alternative response to existing rule\"\"\"\n        self.list_rules()\n        rule_id = await ainput(\"Masukkan ID aturan yang akan ditambah respons alternatif: \")\n        rule = self.rules_manager.get_rule(rule_id)\n        if not rule:\n            print(f\"Aturan dengan ID {rule_id} tidak ditemukan!\")\n            return\n        new_response = await ainput(\"Masukkan respons alternatif baru: \")\n        if not new_response.strip():\n            print(\"Respons tidak boleh kosong!\")\n            return\n        success, message = self.rules_manager.update_rule(\n            rule_id,\n            response=new_response\n        )\n        print(message)\n\n    async def delete_alternative_response(self):\n        \"\"\"UI for deleting an alternative response\"\"\"\n        self.list_rules()\n        rule_id = await ainput(\"Masukkan ID aturan: \")\n        rule = self.rules_manager.get_rule(rule_id)\n        if not rule:\n            print(f\"Aturan dengan ID {rule_id} tidak ditemukan!\")\n            return\n        responses = rule.get('responses', [])\n        if not responses and 'response' in rule:\n            print(\"Aturan ini menggunakan format lama dan tidak mendukung multiple responses.\")\n            return\n        if len(responses) <= 1:\n            print(\"Aturan harus memiliki minimal satu respons! Hapus aturan jika tidak diperlukan.\")\n            return\n        try:\n            response_index = int(await ainput(f\"Masukkan indeks respons yang akan dihapus (0-{len(responses)-1}): \"))\n            success, message = self.rules_manager.delete_response(rule_id, response_index)\n            print(message)\n        except ValueError:\n            print(\"Indeks respons harus berupa angka!\")\n\n    async def start_responder(self):\n        \"\"\"UI for starting an auto responder with various options\"\"\"\n        if not self.rules_manager.get_all_rules():\n            print(\"Tidak ada aturan auto responder yang tersimpan. Tambahkan aturan terlebih dahulu.\")\n            return\n        accounts = self.db_manager.get_all_accounts()\n        if not accounts:\n            print(\"Tidak ada akun yang tersimpan.\")\n            return\n        print(\"\\nPilih opsi untuk auto responder:\")\n        print(\"1. Pilih akun spesifik\")\n        print(\"2. Mulai semua akun\")\n        print(\"3. Random 5 akun\")\n        print(\"4. Random 10 akun\")\n        print(\"5. Random 20 akun\")\n        print(\"6. Masukkan jumlah akun random\")\n        option_choice = await ainput(\"Pilih opsi: \")\n        selected_accounts = []\n        try:\n            option = int(option_choice)\n            if option == 1:\n                print(\"\\nPilih akun untuk auto responder:\")\n                for i, account in enumerate(accounts, 1):\n                    print(f\"{i}. {account[2]} ({account[6] if account[6] else 'Tidak ada nama'})\")\n                account_choice = await ainput(\"Pilih nomor akun: \")\n                try:  # Tambahkan blok try-except\n                    account_index = int(account_choice) - 1\n                    if account_index < 0 or account_index >= len(accounts):\n                        print(\"Pilihan tidak valid!\")\n                        return\n                    selected_accounts = [accounts[account_index]]\n                except ValueError:  # Tangkap kesalahan ValueError\n                    print(\"Input harus berupa angka!\")\n                    return\n            elif option == 2:\n                selected_accounts = accounts\n            elif option in [3, 4, 5]:\n                num_accounts = {3: 5, 4: 10, 5: 20}.get(option)\n                if len(accounts) <= num_accounts:\n                    selected_accounts = accounts\n                else:\n                    selected_accounts = random.sample(accounts, num_accounts)\n            elif option == 6:\n                num_random = await ainput(\"Masukkan jumlah akun random: \")\n                try:\n                    num_random = int(num_random)\n                    if num_random <= 0:\n                        print(\"Jumlah akun harus lebih dari 0!\")\n                        return\n                    if len(accounts) <= num_random:\n                        selected_accounts = accounts\n                    else:\n                        selected_accounts = random.sample(accounts, num_random)\n                except ValueError:\n                    print(\"Input harus berupa angka!\")\n                    return\n            else:\n                print(\"Pilihan tidak valid!\")\n                return\n            print(\"\\nPengaturan waktu respons:\")\n            delay_config = await ainput(\"Total waktu respons (dalam menit, misalnya 120 untuk 2 jam): \")\n            try:\n                delay_minutes = float(delay_config)\n                if delay_minutes <= 0:\n                    print(\"Waktu respons minimal 1 menit!\")\n                    return\n                total_delay_seconds = delay_minutes * 60\n                print(f\"\\nMenyiapkan {len(selected_accounts)} akun dengan estimasi waktu respons {delay_minutes} menit\")\n                activated_count = 0\n                for account in selected_accounts:\n                    api_id, api_hash, phone = account[0], account[1], account[2]\n                    if phone in self.client_manager.active_clients:\n                        print(f\"Auto responder untuk {phone} sudah berjalan!\")\n                        continue\n                    client = await self.client_manager.create_client(api_id, api_hash, phone)\n                    if not await client.is_user_authorized():\n                        print(f\"Akun {phone} belum diotorisasi. Silakan login terlebih dahulu.\")\n                        await client.disconnect()\n                        continue\n                    variation = random.uniform(0.8, 1.2)\n                    account_delay = total_delay_seconds / len(selected_accounts) * variation\n                    self.message_handler.setup_handler(client, phone, account_delay)\n                    self.client_manager.add_active_client(phone, client)\n                    activated_count += 1\n                    await asyncio.sleep(0.2)\n                if activated_count > 0:\n                    print(f\"\\n{activated_count} akun berhasil diaktifkan!\")\n                    print(f\"Estimasi waktu respons: {delay_minutes} menit ({delay_minutes/60:.1f} jam)\")\n                    print(\"Setiap akun akan merespons dengan delay yang berbeda untuk pola lebih natural\")\n                else:\n                    print(\"Tidak ada akun yang berhasil diaktifkan.\")\n            except ValueError:\n                print(\"Input waktu harus berupa angka!\")\n                return\n        except ValueError:\n            print(\"Input harus berupa angka!\")\n        except Exception as e:\n            logging.error(f\"Gagal memulai auto responder: {str(e)}\")\n            print(f\"Gagal memulai auto responder: {str(e)}\")\n\n    async def stop_responder(self):\n        \"\"\"UI for stopping an auto responder\"\"\"\n        active_clients = self.client_manager.active_clients\n        if not active_clients:\n            print(\"Tidak ada auto responder yang aktif!\")\n            return\n        print(\"\\nDaftar auto responder yang aktif:\")\n        for i, phone in enumerate(active_clients.keys(), 1):\n            print(f\"{i}. {phone}\")\n        choice = await ainput(\"Pilih nomor auto responder yang akan dihentikan (0 untuk semua): \")\n        try:\n            if choice == '0':\n                for phone in list(active_clients.keys()):\n                    await self.client_manager.disconnect_client(phone)\n                    self.message_handler.remove_handler(phone)\n                print(\"Semua auto responder berhasil dihentikan!\")\n            else:\n                choice_idx = int(choice) - 1\n                if choice_idx < 0 or choice_idx >= len(active_clients):\n                    print(\"Pilihan tidak valid!\")\n                    return\n                phone = list(active_clients.keys())[choice_idx]\n                await self.client_manager.disconnect_client(phone)\n                self.message_handler.remove_handler(phone)\n                print(f\"Auto responder untuk {phone} berhasil dihentikan!\")\n        except ValueError:\n            print(\"Input harus berupa angka!\")\n        except Exception as e:\n            logging.error(f\"Gagal menghentikan auto responder: {str(e)}\")\n            print(f\"Gagal menghentikan auto responder: {str(e)}\")\n\n    async def export_rules(self):\n        \"\"\"UI for exporting rules\"\"\"\n        filename = await ainput(\"Masukkan nama file (default: responder_rules_export.json): \")\n        if not filename.strip():\n            filename = \"responder_rules_export.json\"\n        success, message = self.rules_manager.export_rules(filename)\n        print(message)\n\n    async def import_rules(self):\n        \"\"\"UI for importing rules\"\"\"\n        filename = await ainput(\"Masukkan nama file (default: responder_rules_export.json): \")\n        if not filename.strip():\n            filename = \"responder_rules_export.json\"\n        action = await ainput(\"Ganti aturan yang ada atau gabungkan? (g/m): \")\n        replace = action.lower() == 'g'\n        success, message = self.rules_manager.import_rules(filename, replace)\n        print(message)", "ui\\main_menu.py": "# ui/main_menu.py\nimport asyncio\nimport logging\n\nfrom aioconsole import ainput\n\nclass MainMenu:\n    def __init__(self, account_manager, auto_responder_menu, task_scheduling_menu,\n                 work_cycle_menu, analytics_menu, status_menu):\n        self.account_manager = account_manager\n        self.auto_responder_menu = auto_responder_menu\n        self.task_scheduling_menu = task_scheduling_menu\n        self.work_cycle_menu = work_cycle_menu\n        self.analytics_menu = analytics_menu\n        self.status_menu = status_menu\n\n    async def display_main_menu(self):\n        \"\"\"Display main menu and handle user choices\"\"\"\n        while True:\n            print(\"\\nTelethon Unlimited Login System\")\n            print(\"1. Tambah Akun\")\n            print(\"2. Lihat Semua Akun\")\n            print(\"3. Uji Koneksi\")\n            print(\"4. Hapus Akun\")\n            print(\"5. Auto Responder\")\n            print(\"6. Update Akun\")\n            print(\"7. Export Akun\")\n            print(\"8. Import Akun\")\n            print(\"9. Task Scheduling Menu\")\n            print(\"10. Daily Work Cycle Menu\")\n            print(\"11. Export Analytics Menu\")\n            print(\"12. Status and Statistics Menu\")\n            print(\"13. Keluar\")\n\n            choice = await ainput(\"Pilih menu: \")\n\n            if choice == '1':\n                await self.account_manager.add_account()\n            elif choice == '2':\n                self.account_manager.list_accounts()\n            elif choice == '3':\n                await self.account_manager.test_connection()\n            elif choice == '4':\n                await self.account_manager.delete_account()\n            elif choice == '5':\n                await self.auto_responder_menu.auto_responder_menu()\n            elif choice == '6':\n                await self.account_manager.update_account()\n            elif choice == '7':\n                await self.account_manager.export_accounts()\n            elif choice == '8':\n                await self.account_manager.import_accounts()\n            elif choice == '9':\n                await self.task_scheduling_menu.task_scheduling_menu()\n            elif choice == '10':\n                await self.work_cycle_menu.daily_work_cycle_menu()\n            elif choice == '11':\n                await self.analytics_menu.export_analytics_menu()\n            elif choice == '12':\n                await self.status_menu.status_and_stats_menu()\n            elif choice == '13':\n                break\n            else:\n                print(\"Pilihan tidak valid!\")", "ui\\status.py": "# ui/status.py\nimport asyncio\nimport logging\nimport json\nimport os\nfrom datetime import datetime, timedelta\n\nfrom aioconsole import ainput\nfrom prettytable import PrettyTable\n\nclass StatusMenu:\n    def __init__(self, db_manager, client_manager):\n        self.db_manager = db_manager\n        self.client_manager = client_manager\n        self.start_time = datetime.now()\n        self.status_log_file = 'status_history.json'\n        self.status_history = self._load_status_history()\n\n    def _load_status_history(self):\n        \"\"\"Load status history from file if available\"\"\"\n        if os.path.exists(self.status_log_file):\n            try:\n                with open(self.status_log_file, 'r', encoding='utf-8') as f:\n                    return json.load(f)\n            except Exception as e:\n                logging.error(f\"Error loading status history: {str(e)}\")\n        return []\n\n    def _save_status_history(self):\n        \"\"\"Save status history to file\"\"\"\n        try:\n            with open(self.status_log_file, 'w', encoding='utf-8') as f:\n                json.dump(self.status_history, f, indent=4)\n            return True\n        except Exception as e:\n            logging.error(f\"Error saving status history: {str(e)}\")\n            return False\n\n    def _add_status_record(self, record):\n        \"\"\"Add a status record to history\"\"\"\n        self.status_history.append(record)\n        # Keep only the last 100 records to prevent file growth\n        if len(self.status_history) > 100:\n            self.status_history = self.status_history[-100:]\n        return self._save_status_history()\n\n    async def status_and_stats_menu(self):\n        \"\"\"UI for status and statistics menu\"\"\"\n        while True:\n            print(\"\\nStatus and Statistics Menu\")\n            print(\"1. View System Status\")\n            print(\"2. View Account Statistics\")\n            print(\"3. View Active Clients\")\n            print(\"4. View Status History\")\n            print(\"5. Check System Health\")\n            print(\"6. Export Status Report\")\n            print(\"7. Kembali ke Menu Utama\")\n            choice = await ainput(\"Pilih menu: \")\n            if choice == '1':\n                await self.view_system_status()\n            elif choice == '2':\n                await self.view_account_statistics()\n            elif choice == '3':\n                await self.view_active_clients()\n            elif choice == '4':\n                await self.view_status_history()\n            elif choice == '5':\n                await self.check_system_health()\n            elif choice == '6':\n                await self.export_status_report()\n            elif choice == '7':\n                break\n            else:\n                print(\"Pilihan tidak valid!\")\n\n    async def view_system_status(self):\n        \"\"\"Display system status including uptime and active components\"\"\"\n        # Calculate uptime\n        uptime = datetime.now() - self.start_time\n        uptime_str = str(uptime).split('.')[0]  # Remove microseconds\n        \n        # Get account and client statistics\n        total_accounts = len(self.db_manager.get_all_accounts())\n        active_clients = len(self.client_manager.active_clients)\n        \n        # Get database info\n        try:\n            conn, cursor = self.db_manager.get_connection()\n            cursor.execute(\"PRAGMA page_count\")\n            page_count = cursor.fetchone()[0]\n            cursor.execute(\"PRAGMA page_size\")\n            page_size = cursor.fetchone()[0]\n            db_size = page_count * page_size / (1024 * 1024)  # Size in MB\n        except Exception as e:\n            logging.error(f\"Error getting database info: {str(e)}\")\n            db_size = 0\n        \n        # Check if session files exist\n        session_count = 0\n        if os.path.exists('session'):\n            session_count = len([f for f in os.listdir('session') if f.endswith('.session')])\n        \n        # Display status info\n        print(\"\\n--- System Status ---\")\n        print(f\"Uptime: {uptime_str}\")\n        print(f\"Total Accounts: {total_accounts}\")\n        print(f\"Active Clients: {active_clients}\")\n        print(f\"Session Files: {session_count}\")\n        print(f\"Database Size: {db_size:.2f} MB\")\n        print(f\"Status Records: {len(self.status_history)}\")\n        \n        # Add status record to history\n        status_record = {\n            \"timestamp\": datetime.now().isoformat(),\n            \"uptime\": uptime_str,\n            \"total_accounts\": total_accounts,\n            \"active_clients\": active_clients,\n            \"session_files\": session_count,\n            \"db_size_mb\": round(db_size, 2)\n        }\n        self._add_status_record(status_record)\n        \n        # Show additional system info menu\n        print(\"\\nOptions:\")\n        print(\"1. Check Database Integrity\")\n        print(\"2. View Log Summary\")\n        print(\"3. Back\")\n        \n        choice = await ainput(\"Pilih opsi: \")\n        if choice == '1':\n            await self._check_database_integrity()\n        elif choice == '2':\n            await self._view_log_summary()\n\n    async def _check_database_integrity(self):\n        \"\"\"Check database integrity\"\"\"\n        print(\"\\nMemeriksa integritas database...\")\n        try:\n            conn, cursor = self.db_manager.get_connection()\n            cursor.execute(\"PRAGMA integrity_check\")\n            result = cursor.fetchone()[0]\n            \n            if result == \"ok\":\n                print(\"\u2705 Database integrity check passed\")\n            else:\n                print(f\"\u26a0\ufe0f Database integrity issues found: {result}\")\n                \n            # Check for database optimizations\n            cursor.execute(\"PRAGMA auto_vacuum\")\n            auto_vacuum = cursor.fetchone()[0]\n            \n            cursor.execute(\"PRAGMA journal_mode\")\n            journal_mode = cursor.fetchone()[0]\n            \n            print(f\"\\nDatabase settings:\")\n            print(f\"Auto Vacuum: {auto_vacuum}\")\n            print(f\"Journal Mode: {journal_mode}\")\n            \n            if auto_vacuum == 0:\n                print(\"\u26a0\ufe0f Consider enabling auto_vacuum to reduce database size over time\")\n            if journal_mode.lower() != \"wal\":\n                print(\"\u26a0\ufe0f Consider using WAL journal mode for better performance\")\n        except Exception as e:\n            logging.error(f\"Error checking database integrity: {str(e)}\")\n            print(f\"Error checking database: {str(e)}\")\n\n    async def _view_log_summary(self):\n        \"\"\"Display summary of recent logs\"\"\"\n        print(\"\\nLog Summary:\")\n        log_dir = 'logs'\n        \n        if not os.path.exists(log_dir):\n            print(\"Log directory not found\")\n            return\n        \n        # Get today's log file\n        today = datetime.now().strftime('%Y-%m-%d')\n        log_file = os.path.join(log_dir, f\"{today}.log\")\n        \n        if not os.path.exists(log_file):\n            print(f\"No log file found for today ({log_file})\")\n            # Try to find the most recent log file\n            log_files = sorted([f for f in os.listdir(log_dir) if f.endswith('.log')], reverse=True)\n            if log_files:\n                log_file = os.path.join(log_dir, log_files[0])\n                print(f\"Using most recent log file: {log_file}\")\n            else:\n                print(\"No log files found\")\n                return\n        \n        # Read the last 20 log entries\n        try:\n            with open(log_file, 'r', encoding='utf-8') as f:\n                lines = f.readlines()\n            \n            # Count log levels\n            log_levels = {'INFO': 0, 'ERROR': 0, 'WARNING': 0, 'DEBUG': 0, 'CRITICAL': 0}\n            for line in lines:\n                for level in log_levels.keys():\n                    if f' - {level} - ' in line:\n                        log_levels[level] += 1\n            \n            print(\"\\nLog level summary:\")\n            for level, count in log_levels.items():\n                print(f\"{level}: {count}\")\n            \n            # Show the last 10 lines\n            print(\"\\nRecent log entries:\")\n            for line in lines[-10:]:\n                print(line.strip())\n        except Exception as e:\n            logging.error(f\"Error reading log file: {str(e)}\")\n            print(f\"Error reading log file: {str(e)}\")\n\n    async def view_account_statistics(self):\n        \"\"\"Display account statistics using a table\"\"\"\n        accounts = self.db_manager.get_all_accounts()\n        if not accounts:\n            print(\"Tidak ada data akun untuk ditampilkan.\")\n            return\n        \n        # Create main table\n        table = PrettyTable()\n        table.field_names = [\"API ID\", \"Phone\", \"User ID\", \"Username\", \"Name\"]\n        \n        # Add rows\n        for row in accounts:\n            table.add_row([row[0], row[2], row[4], row[5], row[6]])\n        \n        print(\"\\n--- Account Statistics ---\")\n        print(table)\n        \n        # Add account summary\n        print(\"\\nAccount Summary:\")\n        print(f\"Total Accounts: {len(accounts)}\")\n        \n        # Count accounts with username\n        accounts_with_username = sum(1 for row in accounts if row[5])\n        print(f\"Accounts with Username: {accounts_with_username} ({accounts_with_username/len(accounts)*100:.1f}%)\")\n        \n        # Show additional account options\n        print(\"\\nOptions:\")\n        print(\"1. Search Account\")\n        print(\"2. Sort Accounts\")\n        print(\"3. View Account Distribution\")\n        print(\"4. Back\")\n        \n        choice = await ainput(\"Pilih opsi: \")\n        if choice == '1':\n            await self._search_account()\n        elif choice == '2':\n            await self._sort_accounts()\n        elif choice == '3':\n            await self._view_account_distribution()\n\n    async def _search_account(self):\n        \"\"\"Search for specific account\"\"\"\n        search_term = await ainput(\"Masukkan kata kunci pencarian (phone/username/name): \")\n        if not search_term.strip():\n            return\n        \n        accounts = self.db_manager.get_all_accounts()\n        results = []\n        \n        for row in accounts:\n            # Search in phone, username, and name\n            if (search_term.lower() in str(row[2]).lower() or  # phone\n                (row[5] and search_term.lower() in str(row[5]).lower()) or  # username\n                (row[6] and search_term.lower() in str(row[6]).lower())):  # name\n                results.append(row)\n        \n        if not results:\n            print(f\"Tidak ditemukan akun dengan kata kunci '{search_term}'\")\n            return\n        \n        # Display results\n        table = PrettyTable()\n        table.field_names = [\"API ID\", \"Phone\", \"User ID\", \"Username\", \"Name\"]\n        \n        for row in results:\n            table.add_row([row[0], row[2], row[4], row[5], row[6]])\n        \n        print(f\"\\nHasil pencarian untuk '{search_term}' ({len(results)} akun):\")\n        print(table)\n\n    async def _sort_accounts(self):\n        \"\"\"Sort accounts by different criteria\"\"\"\n        print(\"\\nSort by:\")\n        print(\"1. API ID\")\n        print(\"2. Phone\")\n        print(\"3. Username\")\n        print(\"4. Name\")\n        \n        choice = await ainput(\"Pilih kriteria pengurutan: \")\n        \n        sort_index = {\n            '1': 0,  # API ID\n            '2': 2,  # Phone\n            '3': 5,  # Username\n            '4': 6   # Name\n        }.get(choice)\n        \n        if sort_index is None:\n            print(\"Pilihan tidak valid!\")\n            return\n        \n        accounts = self.db_manager.get_all_accounts()\n        \n        # Sort accounts\n        # Handle None values in sort\n        sorted_accounts = sorted(accounts, key=lambda x: str(x[sort_index] or '').lower())\n        \n        # Display sorted accounts\n        table = PrettyTable()\n        table.field_names = [\"API ID\", \"Phone\", \"User ID\", \"Username\", \"Name\"]\n        \n        for row in sorted_accounts:\n            table.add_row([row[0], row[2], row[4], row[5], row[6]])\n        \n        print(\"\\nAkun terurut:\")\n        print(table)\n\n    async def _view_account_distribution(self):\n        \"\"\"View account distribution by username presence\"\"\"\n        accounts = self.db_manager.get_all_accounts()\n        \n        # Count accounts with/without username\n        with_username = 0\n        without_username = 0\n        \n        for row in accounts:\n            if row[5]:  # Username exists\n                with_username += 1\n            else:\n                without_username += 1\n        \n        print(\"\\nDistribusi Akun:\")\n        print(f\"Dengan Username: {with_username} ({with_username/len(accounts)*100:.1f}%)\")\n        print(f\"Tanpa Username: {without_username} ({without_username/len(accounts)*100:.1f}%)\")\n        \n        # Create a simple ASCII chart\n        total_width = 50\n        with_width = int(with_username / len(accounts) * total_width)\n        without_width = total_width - with_width\n        \n        print(\"\\nDistribusi Visual:\")\n        print(\"Dengan Username    : \" + \"\u2588\" * with_width + f\" {with_username}\")\n        print(\"Tanpa Username     : \" + \"\u2588\" * without_width + f\" {without_username}\")\n\n    async def view_active_clients(self):\n        \"\"\"Display information about active clients\"\"\"\n        active_clients = self.client_manager.active_clients\n        \n        if not active_clients:\n            print(\"Tidak ada klien aktif saat ini.\")\n            return\n        \n        print(f\"\\n--- Active Clients ({len(active_clients)}) ---\")\n        \n        # Get account info for active clients\n        client_info = []\n        for phone, client in active_clients.items():\n            # Find account info\n            account_info = None\n            accounts = self.db_manager.get_all_accounts()\n            for account in accounts:\n                if account[2] == phone:  # Match by phone\n                    account_info = account\n                    break\n            \n            # Check connection status\n            is_connected = False\n            user_id = None\n            username = None\n            try:\n                is_connected = client.is_connected()\n                if is_connected:\n                    # This would be async but we're simplifying for this example\n                    pass\n            except Exception as e:\n                logging.error(f\"Error checking client connection for {phone}: {str(e)}\")\n            \n            client_info.append({\n                'phone': phone,\n                'connected': is_connected,\n                'api_id': account_info[0] if account_info else None,\n                'username': account_info[5] if account_info else None,\n                'name': account_info[6] if account_info else None\n            })\n        \n        # Display clients in table\n        table = PrettyTable()\n        table.field_names = [\"Phone\", \"Connected\", \"API ID\", \"Username\", \"Name\"]\n        \n        for info in client_info:\n            table.add_row([\n                info['phone'],\n                \"\u2705\" if info['connected'] else \"\u274c\",\n                info['api_id'],\n                info['username'],\n                info['name']\n            ])\n        \n        print(table)\n        \n        # Show options for active clients\n        print(\"\\nOptions:\")\n        print(\"1. Disconnect Client\")\n        print(\"2. Disconnect All Clients\")\n        print(\"3. Back\")\n        \n        choice = await ainput(\"Pilih opsi: \")\n        if choice == '1':\n            await self._disconnect_client()\n        elif choice == '2':\n            await self._disconnect_all_clients()\n\n    async def _disconnect_client(self):\n        \"\"\"Disconnect a specific client\"\"\"\n        active_clients = self.client_manager.active_clients\n        \n        if not active_clients:\n            print(\"Tidak ada klien aktif untuk diputuskan.\")\n            return\n        \n        print(\"\\nDaftar klien aktif:\")\n        for i, phone in enumerate(active_clients.keys(), 1):\n            print(f\"{i}. {phone}\")\n        \n        choice = await ainput(\"Pilih nomor klien yang akan diputuskan: \")\n        try:\n            idx = int(choice) - 1\n            if idx < 0 or idx >= len(active_clients):\n                print(\"Pilihan tidak valid!\")\n                return\n            \n            phone = list(active_clients.keys())[idx]\n            \n            print(f\"Memutuskan koneksi klien {phone}...\")\n            result = await self.client_manager.disconnect_client(phone)\n            \n            if result:\n                print(f\"Klien {phone} berhasil diputuskan.\")\n            else:\n                print(f\"Gagal memutuskan klien {phone}.\")\n        except ValueError:\n            print(\"Input harus berupa angka!\")\n        except Exception as e:\n            logging.error(f\"Error disconnecting client: {str(e)}\")\n            print(f\"Error: {str(e)}\")\n\n    async def _disconnect_all_clients(self):\n        \"\"\"Disconnect all active clients\"\"\"\n        active_clients = self.client_manager.active_clients\n        \n        if not active_clients:\n            print(\"Tidak ada klien aktif untuk diputuskan.\")\n            return\n        \n        confirm = await ainput(f\"Apakah Anda yakin ingin memutuskan {len(active_clients)} klien aktif? (y/n): \")\n        if confirm.lower() != 'y':\n            return\n        \n        print(\"Memutuskan semua klien aktif...\")\n        await self.client_manager.disconnect_all_clients()\n        print(\"Semua klien telah diputuskan.\")\n\n    async def view_status_history(self):\n        \"\"\"View historical status records\"\"\"\n        if not self.status_history:\n            print(\"Tidak ada riwayat status yang tersimpan.\")\n            return\n        \n        # Sort by timestamp (newest first)\n        sorted_history = sorted(\n            self.status_history,\n            key=lambda x: x.get('timestamp', ''),\n            reverse=True\n        )\n        \n        # Display options\n        print(\"\\nOpsi tampilan:\")\n        print(\"1. Tampilkan 5 riwayat terbaru\")\n        print(\"2. Tampilkan 10 riwayat terbaru\")\n        print(\"3. Tampilkan semua riwayat\")\n        print(\"4. Bandingkan dua riwayat\")\n        print(\"5. Grafik perubahan akun\")\n        print(\"6. Kembali\")\n        \n        choice = await ainput(\"Pilih opsi: \")\n        \n        if choice == '1':\n            limit = 5\n        elif choice == '2':\n            limit = 10\n        elif choice == '3':\n            limit = len(sorted_history)\n        elif choice == '4':\n            await self._compare_status_records()\n            return\n        elif choice == '5':\n            await self._show_account_changes()\n            return\n        elif choice == '6':\n            return\n        else:\n            print(\"Pilihan tidak valid!\")\n            return\n        \n        # Display records in table\n        table = PrettyTable()\n        table.field_names = [\"No\", \"Timestamp\", \"Uptime\", \"Total Accounts\", \"Active Clients\"]\n        \n        for i, record in enumerate(sorted_history[:limit], 1):\n            timestamp = datetime.fromisoformat(record.get('timestamp', '')).strftime('%Y-%m-%d %H:%M:%S')\n            table.add_row([\n                i,\n                timestamp,\n                record.get('uptime', 'N/A'),\n                record.get('total_accounts', 0),\n                record.get('active_clients', 0)\n            ])\n        \n        print(\"\\nRiwayat Status:\")\n        print(table)\n\n    async def _compare_status_records(self):\n        \"\"\"Compare two status records\"\"\"\n        if len(self.status_history) < 2:\n            print(\"Minimal 2 riwayat status diperlukan untuk perbandingan.\")\n            return\n        \n        # Sort by timestamp (newest first)\n        sorted_history = sorted(\n            self.status_history,\n            key=lambda x: x.get('timestamp', ''),\n            reverse=True\n        )\n        \n        # Display records for selection\n        print(\"\\nDaftar Riwayat Status:\")\n        for i, record in enumerate(sorted_history, 1):\n            timestamp = datetime.fromisoformat(record.get('timestamp', '')).strftime('%Y-%m-%d %H:%M:%S')\n            print(f\"{i}. {timestamp} - Accounts: {record.get('total_accounts', 0)}, Clients: {record.get('active_clients', 0)}\")\n        \n        # Get selections\n        try:\n            idx1 = int(await ainput(\"\\nPilih riwayat pertama (#): \")) - 1\n            idx2 = int(await ainput(\"Pilih riwayat kedua (#): \")) - 1\n            \n            if idx1 < 0 or idx1 >= len(sorted_history) or idx2 < 0 or idx2 >= len(sorted_history):\n                print(\"Pilihan tidak valid!\")\n                return\n            \n            record1 = sorted_history[idx1]\n            record2 = sorted_history[idx2]\n            \n            # Ensure record1 is the newer one\n            if datetime.fromisoformat(record1.get('timestamp', '')) < datetime.fromisoformat(record2.get('timestamp', '')):\n                record1, record2 = record2, record1\n            \n            # Format timestamps\n            time1 = datetime.fromisoformat(record1.get('timestamp', '')).strftime('%Y-%m-%d %H:%M:%S')\n            time2 = datetime.fromisoformat(record2.get('timestamp', '')).strftime('%Y-%m-%d %H:%M:%S')\n            \n            # Calculate differences\n            account_diff = record1.get('total_accounts', 0) - record2.get('total_accounts', 0)\n            client_diff = record1.get('active_clients', 0) - record2.get('active_clients', 0)\n            \n            # Calculate time difference\n            time_diff = datetime.fromisoformat(record1.get('timestamp', '')) - datetime.fromisoformat(record2.get('timestamp', ''))\n            \n            # Display comparison\n            print(f\"\\nPerbandingan antara {time1} dan {time2}\")\n            print(f\"Selisih waktu: {time_diff}\")\n            print(f\"Perubahan Total Accounts: {account_diff:+d}\")\n            print(f\"Perubahan Active Clients: {client_diff:+d}\")\n            \n            # Display detailed table\n            table = PrettyTable()\n            table.field_names = [\"Metrik\", \"Nilai Lama\", \"Nilai Baru\", \"Perubahan\"]\n            \n            table.add_row([\"Timestamp\", time2, time1, f\"{time_diff}\"])\n            table.add_row([\"Total Accounts\", record2.get('total_accounts', 0), record1.get('total_accounts', 0), \n                          f\"{account_diff:+d}\"])\n            table.add_row([\"Active Clients\", record2.get('active_clients', 0), record1.get('active_clients', 0), \n                          f\"{client_diff:+d}\"])\n            table.add_row([\"Database Size\", f\"{record2.get('db_size_mb', 0):.2f} MB\", f\"{record1.get('db_size_mb', 0):.2f} MB\", \n                          f\"{record1.get('db_size_mb', 0) - record2.get('db_size_mb', 0):+.2f} MB\"])\n            \n            print(table)\n        except ValueError:\n            print(\"Input harus berupa angka!\")\n        except Exception as e:\n            logging.error(f\"Error comparing status records: {str(e)}\")\n            print(f\"Error: {str(e)}\")\n\n    async def _show_account_changes(self):\n        \"\"\"Show account changes over time\"\"\"\n        if len(self.status_history) < 2:\n            print(\"Minimal 2 riwayat status diperlukan untuk analisis perubahan.\")\n            return\n        \n        # Sort by timestamp\n        sorted_history = sorted(\n            self.status_history,\n            key=lambda x: x.get('timestamp', '')\n        )\n        \n        # Extract data for display\n        timestamps = []\n        account_counts = []\n        client_counts = []\n        \n        for record in sorted_history:\n            timestamp = datetime.fromisoformat(record.get('timestamp', '')).strftime('%m-%d %H:%M')\n            timestamps.append(timestamp)\n            account_counts.append(record.get('total_accounts', 0))\n            client_counts.append(record.get('active_clients', 0))\n        \n        # Display as ASCII chart (simple)\n        print(\"\\nPerubahan Jumlah Akun:\")\n        max_accounts = max(account_counts)\n        chart_width = 40\n        \n        for i, (time, count) in enumerate(zip(timestamps, account_counts)):\n            bar_width = int(count / max_accounts * chart_width) if max_accounts > 0 else 0\n            print(f\"{time}: {'\u2588' * bar_width} {count}\")\n        \n        print(\"\\nPerubahan Jumlah Klien Aktif:\")\n        max_clients = max(client_counts) if client_counts else 0\n        \n        for i, (time, count) in enumerate(zip(timestamps, client_counts)):\n            bar_width = int(count / max_clients * chart_width) if max_clients > 0 else 0\n            print(f\"{time}: {'\u2588' * bar_width} {count}\")\n\n    async def check_system_health(self):\n        \"\"\"Check system health and display status\"\"\"\n        print(\"\\n--- System Health Check ---\")\n        \n        # Check uptime\n        uptime = datetime.now() - self.start_time\n        print(f\"System Uptime: {str(uptime).split('.')[0]}\")\n        \n        # Check database\n        try:\n            conn, cursor = self.db_manager.get_connection()\n            \n            # Check if database is locked\n            try:\n                cursor.execute(\"BEGIN IMMEDIATE\")\n                cursor.execute(\"COMMIT\")\n                print(\"\u2705 Database: Available (not locked)\")\n            except Exception as e:\n                print(f\"\u26a0\ufe0f Database: Locked or busy ({str(e)})\")\n            \n            # Check database size\n            cursor.execute(\"PRAGMA page_count\")\n            page_count = cursor.fetchone()[0]\n            cursor.execute(\"PRAGMA page_size\")\n            page_size = cursor.fetchone()[0]\n            db_size = page_count * page_size / (1024 * 1024)  # Size in MB\n            \n            db_status = \"Normal\"\n            if db_size > 100:\n                db_status = \"Large\"\n            \n            print(f\"\u2705 Database Size: {db_size:.2f} MB ({db_status})\")\n            \n            # Check database integrity\n            cursor.execute(\"PRAGMA quick_check\")\n            integrity = cursor.fetchone()[0]\n            if integrity == \"ok\":\n                print(\"\u2705 Database Integrity: Good\")\n            else:\n                print(f\"\u26a0\ufe0f Database Integrity: Issues found ({integrity})\")\n        except Exception as e:\n            logging.error(f\"Database check error: {str(e)}\")\n            print(f\"\u274c Database Check: Error ({str(e)})\")\n        \n        # Check active clients\n        active_clients = len(self.client_manager.active_clients)\n        print(f\"\u2705 Active Clients: {active_clients}\")\n        \n        # Check disk space\n        try:\n            total, used, free = shutil.disk_usage('/')\n            free_gb = free / (1024**3)\n            print(f\"\u2705 Free Disk Space: {free_gb:.2f} GB\")\n            \n            if free_gb < 1:\n                print(\"\u26a0\ufe0f Low disk space! Less than 1GB available.\")\n        except Exception as e:\n            logging.error(f\"Disk check error: {str(e)}\")\n            print(\"\u26a0\ufe0f Disk Space Check: Could not determine\")\n        \n        # Check log files\n        log_dir = 'logs'\n        if os.path.exists(log_dir):\n            log_files = [f for f in os.listdir(log_dir) if f.endswith('.log')]\n            log_count = len(log_files)\n            \n            # Get size of log files\n            log_size = sum(os.path.getsize(os.path.join(log_dir, f)) for f in log_files) / (1024 * 1024)  # MB\n            \n            print(f\"\u2705 Log Files: {log_count} files ({log_size:.2f} MB)\")\n            \n            # Check for error frequency in most recent log\n            if log_files:\n                newest_log = max(log_files, key=lambda f: os.path.getmtime(os.path.join(log_dir, f)))\n                try:\n                    with open(os.path.join(log_dir, newest_log), 'r', encoding='utf-8') as f:\n                        content = f.read()\n                        error_count = content.count(\" - ERROR - \")\n                        if error_count > 10:\n                            print(f\"\u26a0\ufe0f High Error Count: {error_count} errors in {newest_log}\")\n                        else:\n                            print(f\"\u2705 Error Frequency: {error_count} errors in {newest_log}\")\n                except Exception as e:\n                    logging.error(f\"Log check error: {str(e)}\")\n        else:\n            print(\"\u26a0\ufe0f Log Directory: Not found\")\n        \n        # Overall health assessment\n        print(\"\\nOverall System Health: Good\")\n\n    async def export_status_report(self):\n        \"\"\"Export a comprehensive status report\"\"\"\n        # Collect current status\n        uptime = datetime.now() - self.start_time\n        uptime_str = str(uptime).split('.')[0]\n        \n        total_accounts = len(self.db_manager.get_all_accounts())\n        active_clients = len(self.client_manager.active_clients)\n        \n        # Generate report data\n        report = {\n            \"timestamp\": datetime.now().isoformat(),\n            \"system\": {\n                \"uptime\": uptime_str,\n                \"uptime_seconds\": int(uptime.total_seconds())\n            },\n            \"accounts\": {\n                \"total\": total_accounts,\n                \"active_clients\": active_clients\n            },\n            \"history\": {\n                \"status_records\": len(self.status_history),\n                \"recent_changes\": []\n            }\n        }\n        \n        # Add recent changes if available\n        if len(self.status_history) >= 2:\n            sorted_history = sorted(\n                self.status_history,\n                key=lambda x: x.get('timestamp', ''),\n                reverse=True\n            )\n            \n            recent1 = sorted_history[0]\n            recent2 = sorted_history[1]\n            \n            report[\"history\"][\"recent_changes\"] = {\n                \"timespan\": (datetime.fromisoformat(recent1.get('timestamp', '')) - \n                            datetime.fromisoformat(recent2.get('timestamp', ''))).total_seconds(),\n                \"account_change\": recent1.get('total_accounts', 0) - recent2.get('total_accounts', 0),\n                \"client_change\": recent1.get('active_clients', 0) - recent2.get('active_clients', 0)\n            }\n        \n        # Get filename from user\n        filename = await ainput(\"Masukkan nama file untuk status report (default: system_status_report.json): \")\n        if not filename.strip():\n            filename = \"system_status_report.json\"\n        \n        # Ensure .json extension\n        if not filename.lower().endswith('.json'):\n            filename += '.json'\n        \n        # Save to file\n        try:\n            with open(filename, 'w', encoding='utf-8') as f:\n                json.dump(report, f, indent=4)\n            print(f\"Status report berhasil disimpan ke {filename}\")\n            \n            # Ask if user wants a text report too\n            text_report = await ainput(\"Buat juga laporan teks (y/n)? \")\n            if text_report.lower() == 'y':\n                text_filename = filename.replace('.json', '.txt')\n                with open(text_filename, 'w', encoding='utf-8') as f:\n                    f.write(f\"SYSTEM STATUS REPORT\\n\")\n                    f.write(f\"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\\n\\n\")\n                    \n                    f.write(\"SYSTEM INFORMATION\\n\")\n                    f.write(f\"Uptime: {uptime_str}\\n\")\n                    \n                    f.write(\"\\nACCOUNT INFORMATION\\n\")\n                    f.write(f\"Total Accounts: {total_accounts}\\n\")\n                    f.write(f\"Active Clients: {active_clients}\\n\")\n                    \n                    if \"recent_changes\" in report[\"history\"]:\n                        f.write(\"\\nRECENT CHANGES\\n\")\n                        changes = report[\"history\"][\"recent_changes\"]\n                        f.write(f\"Account Change: {changes['account_change']:+d}\\n\")\n                        f.write(f\"Client Change: {changes['client_change']:+d}\\n\")\n                \n                print(f\"Laporan teks berhasil disimpan ke {text_filename}\")\n        except Exception as e:\n            logging.error(f\"Error exporting status report: {str(e)}\")\n            print(f\"Gagal menyimpan status report: {str(e)}\")\n\n\n# Try to import shutil for disk space check, but don't fail if not available\ntry:\n    import shutil\nexcept ImportError:\n    logging.warning(\"shutil module not available, disk space check will be limited\")", "ui\\task_scheduling.py": "# ui/task_scheduling.py\nimport asyncio\nimport logging\nimport json\nimport os\nfrom datetime import datetime, timedelta\n\nfrom aioconsole import ainput\nfrom prettytable import PrettyTable\n\nclass TaskSchedulingMenu:\n    def __init__(self):\n        self.scheduled_tasks = {}  # task_id -> task_info dict\n        self.task_id_counter = 1\n        self.tasks_file = 'tasks_data.json'\n        self._load_tasks()\n\n    def _load_tasks(self):\n        \"\"\"Load saved tasks from file\"\"\"\n        try:\n            if os.path.exists(self.tasks_file):\n                with open(self.tasks_file, 'r', encoding='utf-8') as f:\n                    tasks_data = json.load(f)\n                    \n                    # Reconstruct tasks with datetime objects\n                    for task_id, task_info in tasks_data.items():\n                        if isinstance(task_info['execute_at'], str):\n                            try:\n                                task_info['execute_at'] = datetime.fromisoformat(task_info['execute_at'])\n                            except ValueError:\n                                # Skip invalid tasks\n                                continue\n                        \n                        # Reschedule non-executed tasks\n                        if not task_info.get('executed', False):\n                            # Convert to int as JSON keys are strings\n                            task_id = int(task_id)\n                            if task_id >= self.task_id_counter:\n                                self.task_id_counter = task_id + 1\n                            \n                            # Create new asyncio task\n                            task_future = asyncio.create_task(self._run_task(task_id))\n                            task_info['future'] = task_future\n                            self.scheduled_tasks[task_id] = task_info\n                \n                print(f\"Loaded {len(self.scheduled_tasks)} scheduled tasks from {self.tasks_file}\")\n        except Exception as e:\n            logging.error(f\"Error loading tasks: {str(e)}\")\n            self.scheduled_tasks = {}\n\n    def _save_tasks(self):\n        \"\"\"Save tasks to file for persistence\"\"\"\n        try:\n            # Prepare data for JSON serialization\n            tasks_data = {}\n            for task_id, task_info in self.scheduled_tasks.items():\n                # Create a copy without the future field\n                task_data = task_info.copy()\n                if 'future' in task_data:\n                    del task_data['future']\n                \n                # Convert datetime to string\n                if isinstance(task_data['execute_at'], datetime):\n                    task_data['execute_at'] = task_data['execute_at'].isoformat()\n                \n                tasks_data[str(task_id)] = task_data\n            \n            with open(self.tasks_file, 'w', encoding='utf-8') as f:\n                json.dump(tasks_data, f, indent=4)\n            \n            return True\n        except Exception as e:\n            logging.error(f\"Error saving tasks: {str(e)}\")\n            return False\n\n    async def task_scheduling_menu(self):\n        \"\"\"UI for task scheduling menu\"\"\"\n        while True:\n            print(\"\\nTask Scheduling Menu\")\n            print(\"1. Add Task\")\n            print(\"2. List Tasks\")\n            print(\"3. Delete Task\")\n            print(\"4. Execute Task Now\")\n            print(\"5. Kembali ke Menu Utama\")\n            choice = await ainput(\"Pilih menu: \")\n            if choice == '1':\n                await self.add_task()\n            elif choice == '2':\n                await self.list_tasks()\n            elif choice == '3':\n                await self.delete_task()\n            elif choice == '4':\n                await self.execute_task_now()\n            elif choice == '5':\n                break\n            else:\n                print(\"Pilihan tidak valid!\")\n\n    async def add_task(self):\n        \"\"\"Add a new task with scheduled execution\"\"\"\n        task_name = await ainput(\"Masukkan nama tugas: \")\n        print(\"\\nJenis tugas:\")\n        print(\"1. Command/Perintah Sistem\")\n        print(\"2. Python Script\")\n        print(\"3. Pengingat\")\n        task_type = await ainput(\"Pilih jenis tugas (1-3): \")\n        \n        task_command = \"\"\n        if task_type == '1':\n            task_command = await ainput(\"Masukkan perintah sistem yang akan dijalankan: \")\n        elif task_type == '2':\n            script_path = await ainput(\"Masukkan path ke file Python: \")\n            args = await ainput(\"Masukkan argumen (opsional): \")\n            task_command = f\"python {script_path} {args}\"\n        elif task_type == '3':\n            task_message = await ainput(\"Masukkan pesan pengingat: \")\n            task_command = f\"REMINDER: {task_message}\"\n        else:\n            print(\"Jenis tugas tidak valid!\")\n            return\n        \n        delay_minutes = await ainput(\"Jadwalkan tugas dalam berapa menit dari sekarang: \")\n        try:\n            delay = float(delay_minutes) * 60  # convert to seconds\n            execute_at = datetime.now() + timedelta(seconds=delay)\n            task_id = self.task_id_counter\n            self.task_id_counter += 1\n\n            task_future = asyncio.create_task(self._run_task(task_id))\n            self.scheduled_tasks[task_id] = {\n                \"name\": task_name,\n                \"type\": int(task_type) if task_type in ['1', '2', '3'] else 3,\n                \"command\": task_command,\n                \"execute_at\": execute_at,\n                \"future\": task_future,\n                \"executed\": False\n            }\n            \n            # Save tasks for persistence\n            if self._save_tasks():\n                print(f\"Tugas '{task_name}' dijadwalkan pada {execute_at.strftime('%Y-%m-%d %H:%M:%S')} dengan ID {task_id}.\")\n            else:\n                print(f\"Tugas '{task_name}' dijadwalkan tetapi gagal disimpan ke file.\")\n        except ValueError:\n            print(\"Input waktu tidak valid!\")\n\n    async def _run_task(self, task_id):\n        \"\"\"Internal: Wait until the task's scheduled time, then execute the task\"\"\"\n        task_info = self.scheduled_tasks.get(task_id)\n        if not task_info:\n            return\n        \n        try:\n            now = datetime.now()\n            delay = (task_info[\"execute_at\"] - now).total_seconds()\n            if delay > 0:\n                await asyncio.sleep(delay)\n            \n            # Execute the task based on its type\n            task_type = task_info.get(\"type\", 3)  # Default to reminder\n            result = \"Executed\"\n            \n            if task_type == 1:  # System command\n                try:\n                    cmd = task_info[\"command\"]\n                    process = await asyncio.create_subprocess_shell(\n                        cmd,\n                        stdout=asyncio.subprocess.PIPE,\n                        stderr=asyncio.subprocess.PIPE\n                    )\n                    stdout, stderr = await process.communicate()\n                    \n                    if process.returncode == 0:\n                        result = f\"Success: {stdout.decode().strip()}\"\n                    else:\n                        result = f\"Error: {stderr.decode().strip()}\"\n                except Exception as e:\n                    result = f\"Execution error: {str(e)}\"\n            \n            elif task_type == 2:  # Python script\n                try:\n                    cmd = task_info[\"command\"]\n                    process = await asyncio.create_subprocess_shell(\n                        cmd,\n                        stdout=asyncio.subprocess.PIPE,\n                        stderr=asyncio.subprocess.PIPE\n                    )\n                    stdout, stderr = await process.communicate()\n                    \n                    if process.returncode == 0:\n                        result = f\"Script executed: {stdout.decode().strip()}\"\n                    else:\n                        result = f\"Script error: {stderr.decode().strip()}\"\n                except Exception as e:\n                    result = f\"Script execution error: {str(e)}\"\n            \n            elif task_type == 3:  # Reminder\n                result = task_info[\"command\"]\n            \n            print(f\"\\n[TASK EXECUTED] Tugas '{task_info['name']}': {result}\")\n            print(f\"Waktu eksekusi: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")\n            \n            task_info[\"executed\"] = True\n            task_info[\"result\"] = result\n            self._save_tasks()\n        except Exception as e:\n            logging.error(f\"Error executing task {task_id}: {str(e)}\")\n            print(f\"\\n[TASK ERROR] Tugas '{task_info['name']}' gagal: {str(e)}\")\n            task_info[\"executed\"] = True\n            task_info[\"result\"] = f\"Error: {str(e)}\"\n            self._save_tasks()\n\n    async def list_tasks(self):\n        \"\"\"List all scheduled tasks\"\"\"\n        if not self.scheduled_tasks:\n            print(\"Tidak ada tugas yang dijadwalkan.\")\n            return\n        \n        table = PrettyTable()\n        table.field_names = [\"Task ID\", \"Nama Tugas\", \"Jenis\", \"Execute At\", \"Status\"]\n        \n        # Classify tasks by status\n        current_tasks = []\n        completed_tasks = []\n        \n        for task_id, info in self.scheduled_tasks.items():\n            task_type_name = {1: \"Command\", 2: \"Script\", 3: \"Reminder\"}.get(info.get(\"type\", 3), \"Unknown\")\n            status = \"Sudah dieksekusi\" if info.get(\"executed\", False) else \"Belum dieksekusi\"\n            execute_time = info[\"execute_at\"].strftime('%Y-%m-%d %H:%M:%S') if isinstance(info[\"execute_at\"], datetime) else info[\"execute_at\"]\n            \n            row = [task_id, info[\"name\"], task_type_name, execute_time, status]\n            \n            if info.get(\"executed\", False):\n                completed_tasks.append(row)\n            else:\n                current_tasks.append(row)\n        \n        # Show active tasks first\n        for row in current_tasks:\n            table.add_row(row)\n        \n        # Then show completed tasks\n        for row in completed_tasks:\n            table.add_row(row)\n        \n        print(\"\\nDaftar Tugas Terjadwal:\")\n        print(table)\n        \n        # Show details of tasks if requested\n        show_details = await ainput(\"Tampilkan detail tugas? (y/n): \")\n        if show_details.lower() == 'y':\n            task_id_str = await ainput(\"Masukkan ID tugas: \")\n            try:\n                task_id = int(task_id_str)\n                if task_id in self.scheduled_tasks:\n                    task_info = self.scheduled_tasks[task_id]\n                    print(f\"\\nDetail Tugas {task_id}:\")\n                    print(f\"Nama: {task_info['name']}\")\n                    task_type_name = {1: \"Command\", 2: \"Script\", 3: \"Reminder\"}.get(task_info.get(\"type\", 3), \"Unknown\")\n                    print(f\"Jenis: {task_type_name}\")\n                    print(f\"Command/Pesan: {task_info['command']}\")\n                    print(f\"Jadwal: {task_info['execute_at'].strftime('%Y-%m-%d %H:%M:%S') if isinstance(task_info['execute_at'], datetime) else task_info['execute_at']}\")\n                    print(f\"Status: {'Sudah dieksekusi' if task_info.get('executed', False) else 'Belum dieksekusi'}\")\n                    if task_info.get(\"executed\", False) and \"result\" in task_info:\n                        print(f\"Hasil: {task_info['result']}\")\n                else:\n                    print(f\"Tugas dengan ID {task_id} tidak ditemukan.\")\n            except ValueError:\n                print(\"Input harus berupa angka!\")\n\n    async def delete_task(self):\n        \"\"\"Delete a scheduled task\"\"\"\n        await self.list_tasks()\n        task_id_input = await ainput(\"Masukkan ID tugas yang akan dihapus: \")\n        try:\n            task_id = int(task_id_input)\n            if task_id in self.scheduled_tasks:\n                task_info = self.scheduled_tasks.pop(task_id)\n                future = task_info.get(\"future\")\n                if future and not future.done():\n                    future.cancel()\n                \n                if self._save_tasks():\n                    print(f\"Tugas dengan ID {task_id} berhasil dihapus.\")\n                else:\n                    print(f\"Tugas dengan ID {task_id} dihapus dari memori tetapi gagal menyimpan perubahan.\")\n            else:\n                print(\"Tugas tidak ditemukan.\")\n        except ValueError:\n            print(\"Input harus berupa angka!\")\n\n    async def execute_task_now(self):\n        \"\"\"Immediately execute a scheduled task\"\"\"\n        await self.list_tasks()\n        task_id_input = await ainput(\"Masukkan ID tugas yang akan dijalankan sekarang: \")\n        try:\n            task_id = int(task_id_input)\n            if task_id in self.scheduled_tasks:\n                task_info = self.scheduled_tasks[task_id]\n                \n                if task_info.get(\"executed\", False):\n                    confirm = await ainput(\"Tugas ini sudah dieksekusi sebelumnya. Jalankan lagi? (y/n): \")\n                    if confirm.lower() != 'y':\n                        return\n                \n                # Cancel existing future if it exists and not done\n                future = task_info.get(\"future\")\n                if future and not future.done():\n                    future.cancel()\n                \n                # Set execution time to now\n                task_info[\"execute_at\"] = datetime.now()\n                \n                # Create a new future for immediate execution\n                new_future = asyncio.create_task(self._run_task(task_id))\n                task_info[\"future\"] = new_future\n                \n                print(f\"Tugas '{task_info['name']}' akan segera dijalankan...\")\n            else:\n                print(\"Tugas tidak ditemukan.\")\n        except ValueError:\n            print(\"Input harus berupa angka!\")", "ui\\work_cycle.py": "# ui/work_cycle.py\nimport asyncio\nimport logging\nimport json\nimport os\nimport random\nfrom datetime import datetime, timedelta\n\nfrom aioconsole import ainput\n\nclass WorkCycleTask:\n    def __init__(self, name, interval_seconds, action_type, data=None):\n        self.name = name\n        self.interval_seconds = interval_seconds\n        self.action_type = action_type  # 'log', 'notification', 'command', etc.\n        self.data = data or {}\n        self.last_run = None\n        self.total_runs = 0\n        self.next_run = datetime.now() + timedelta(seconds=interval_seconds)\n\nclass WorkCycleMenu:\n    def __init__(self, client_manager=None, db_manager=None):\n        self.work_cycle_task = None\n        self.work_cycle_iteration = 0\n        self.work_tasks = {}\n        self.task_id_counter = 1\n        self.config_file = 'work_cycle_config.json'\n        self.client_manager = client_manager\n        self.db_manager = db_manager\n        self._load_config()\n\n    def _load_config(self):\n        \"\"\"Load work cycle configuration from file\"\"\"\n        try:\n            if os.path.exists(self.config_file):\n                with open(self.config_file, 'r', encoding='utf-8') as f:\n                    config = json.load(f)\n                \n                self.work_cycle_iteration = config.get('iteration', 0)\n                \n                # Load tasks\n                for task_id_str, task_data in config.get('tasks', {}).items():\n                    task_id = int(task_id_str)\n                    if task_id >= self.task_id_counter:\n                        self.task_id_counter = task_id + 1\n                    \n                    task = WorkCycleTask(\n                        name=task_data.get('name', 'Unknown Task'),\n                        interval_seconds=task_data.get('interval_seconds', 3600),\n                        action_type=task_data.get('action_type', 'log'),\n                        data=task_data.get('data', {})\n                    )\n                    \n                    # Set run statistics\n                    task.total_runs = task_data.get('total_runs', 0)\n                    if task_data.get('last_run'):\n                        try:\n                            task.last_run = datetime.fromisoformat(task_data['last_run'])\n                        except ValueError:\n                            task.last_run = None\n                    \n                    if task_data.get('next_run'):\n                        try:\n                            task.next_run = datetime.fromisoformat(task_data['next_run'])\n                        except ValueError:\n                            task.next_run = datetime.now() + timedelta(seconds=task.interval_seconds)\n                    \n                    self.work_tasks[task_id] = task\n                \n                print(f\"Loaded work cycle configuration with {len(self.work_tasks)} tasks\")\n        except Exception as e:\n            logging.error(f\"Error loading work cycle configuration: {str(e)}\")\n\n    def _save_config(self):\n        \"\"\"Save work cycle configuration to file\"\"\"\n        try:\n            config = {\n                'iteration': self.work_cycle_iteration,\n                'tasks': {}\n            }\n            \n            for task_id, task in self.work_tasks.items():\n                config['tasks'][str(task_id)] = {\n                    'name': task.name,\n                    'interval_seconds': task.interval_seconds,\n                    'action_type': task.action_type,\n                    'data': task.data,\n                    'total_runs': task.total_runs,\n                    'last_run': task.last_run.isoformat() if task.last_run else None,\n                    'next_run': task.next_run.isoformat() if task.next_run else None\n                }\n            \n            with open(self.config_file, 'w', encoding='utf-8') as f:\n                json.dump(config, f, indent=4)\n            \n            return True\n        except Exception as e:\n            logging.error(f\"Error saving work cycle configuration: {str(e)}\")\n            return False\n\n    async def daily_work_cycle_menu(self):\n        \"\"\"UI for daily work cycle menu\"\"\"\n        while True:\n            print(\"\\nDaily Work Cycle Menu\")\n            print(\"1. Start Work Cycle\")\n            print(\"2. Stop Work Cycle\")\n            print(\"3. View Cycle Status\")\n            print(\"4. Add Work Task\")\n            print(\"5. List Work Tasks\")\n            print(\"6. Delete Work Task\")\n            print(\"7. Kembali ke Menu Utama\")\n            choice = await ainput(\"Pilih menu: \")\n            if choice == '1':\n                await self.start_work_cycle()\n            elif choice == '2':\n                await self.stop_work_cycle()\n            elif choice == '3':\n                await self.view_cycle_status()\n            elif choice == '4':\n                await self.add_work_task()\n            elif choice == '5':\n                await self.list_work_tasks()\n            elif choice == '6':\n                await self.delete_work_task()\n            elif choice == '7':\n                break\n            else:\n                print(\"Pilihan tidak valid!\")\n\n    async def start_work_cycle(self):\n        \"\"\"Start daily work cycle with periodic task execution\"\"\"\n        if self.work_cycle_task and not self.work_cycle_task.done():\n            print(\"Daily work cycle sudah berjalan.\")\n            return\n        \n        # Check if we have tasks\n        if not self.work_tasks:\n            add_default = await ainput(\"Tidak ada tugas terdaftar. Tambahkan tugas default? (y/n): \")\n            if add_default.lower() == 'y':\n                self._add_default_tasks()\n            else:\n                print(\"Work cycle tidak dapat dimulai tanpa tugas.\")\n                return\n        \n        async def work_cycle():\n            try:\n                print(f\"Work cycle dimulai pada {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")\n                \n                while True:\n                    self.work_cycle_iteration += 1\n                    current_time = datetime.now()\n                    \n                    print(f\"[WORK CYCLE] Iterasi {self.work_cycle_iteration} pada {current_time.strftime('%Y-%m-%d %H:%M:%S')}\")\n                    \n                    # Check and execute tasks that are due\n                    tasks_executed = 0\n                    for task_id, task in self.work_tasks.items():\n                        if task.next_run <= current_time:\n                            print(f\"[TASK DUE] '{task.name}' - executing...\")\n                            await self._execute_task(task_id, task)\n                            tasks_executed += 1\n                    \n                    if tasks_executed == 0:\n                        print(\"No tasks were due in this cycle.\")\n                    \n                    # Save configuration after each cycle\n                    self._save_config()\n                    \n                    # Sleep for 60 seconds between checks\n                    await asyncio.sleep(60)\n            except asyncio.CancelledError:\n                print(\"Work cycle cancelled.\")\n                raise\n            except Exception as e:\n                logging.error(f\"Error in work cycle: {str(e)}\")\n                print(f\"Error in work cycle: {str(e)}\")\n        \n        self.work_cycle_task = asyncio.create_task(work_cycle())\n        print(\"Daily work cycle dimulai.\")\n\n    async def _execute_task(self, task_id, task):\n        \"\"\"Execute a specific work task\"\"\"\n        try:\n            task.last_run = datetime.now()\n            task.total_runs += 1\n            \n            # Update next run time\n            task.next_run = task.last_run + timedelta(seconds=task.interval_seconds)\n            \n            # Execute action based on task type\n            if task.action_type == 'log':\n                message = task.data.get('message', f\"Task {task.name} executed at {task.last_run}\")\n                print(f\"[LOG] {message}\")\n                logging.info(message)\n                return True\n            \n            elif task.action_type == 'notification':\n                message = task.data.get('message', f\"Notification: {task.name}\")\n                recipients = task.data.get('recipients', [])\n                print(f\"[NOTIFICATION] {message} to {', '.join(recipients) if recipients else 'no recipients'}\")\n                # Here you could implement actual notification logic\n                return True\n            \n            elif task.action_type == 'command':\n                command = task.data.get('command', '')\n                if command:\n                    print(f\"[COMMAND] Executing: {command}\")\n                    process = await asyncio.create_subprocess_shell(\n                        command,\n                        stdout=asyncio.subprocess.PIPE,\n                        stderr=asyncio.subprocess.PIPE\n                    )\n                    stdout, stderr = await process.communicate()\n                    \n                    if process.returncode == 0:\n                        print(f\"[COMMAND] Success: {stdout.decode().strip()}\")\n                        return True\n                    else:\n                        print(f\"[COMMAND] Error: {stderr.decode().strip()}\")\n                        return False\n                else:\n                    print(\"[COMMAND] No command specified\")\n                    return False\n            \n            elif task.action_type == 'status_update':\n                if self.client_manager and self.db_manager:\n                    total_accounts = len(self.db_manager.get_all_accounts())\n                    active_clients = len(self.client_manager.active_clients)\n                    print(f\"[STATUS] Total Accounts: {total_accounts}, Active Clients: {active_clients}\")\n                    return True\n                else:\n                    print(\"[STATUS] Client or DB manager not available\")\n                    return False\n            \n            else:\n                print(f\"[UNKNOWN] Unknown task type: {task.action_type}\")\n                return False\n                \n        except Exception as e:\n            logging.error(f\"Error executing task {task_id} '{task.name}': {str(e)}\")\n            print(f\"[ERROR] Task {task_id} '{task.name}': {str(e)}\")\n            return False\n\n    def _add_default_tasks(self):\n        \"\"\"Add some default tasks to the work cycle\"\"\"\n        # Status logging task - every hour\n        status_task = WorkCycleTask(\n            name=\"System Status Check\",\n            interval_seconds=3600,  # 1 hour\n            action_type=\"status_update\"\n        )\n        self.work_tasks[self.task_id_counter] = status_task\n        self.task_id_counter += 1\n        \n        # Heartbeat task - every 15 minutes\n        heartbeat_task = WorkCycleTask(\n            name=\"System Heartbeat\",\n            interval_seconds=900,  # 15 minutes\n            action_type=\"log\",\n            data={\"message\": \"System is running normally - heartbeat check\"}\n        )\n        self.work_tasks[self.task_id_counter] = heartbeat_task\n        self.task_id_counter += 1\n        \n        print(\"Added default tasks to work cycle\")\n        self._save_config()\n\n    async def stop_work_cycle(self):\n        \"\"\"Stop the daily work cycle if running\"\"\"\n        if self.work_cycle_task and not self.work_cycle_task.done():\n            self.work_cycle_task.cancel()\n            try:\n                await self.work_cycle_task\n            except asyncio.CancelledError:\n                pass\n            print(\"Daily work cycle dihentikan.\")\n        else:\n            print(\"Daily work cycle tidak berjalan.\")\n\n    async def view_cycle_status(self):\n        \"\"\"Display current status of the daily work cycle\"\"\"\n        if self.work_cycle_task and not self.work_cycle_task.done():\n            print(f\"Daily work cycle berjalan. Iterasi terakhir: {self.work_cycle_iteration}\")\n            \n            # Show upcoming tasks\n            print(\"\\nTugas selanjutnya:\")\n            current_time = datetime.now()\n            upcoming_tasks = sorted(\n                [(task_id, task) for task_id, task in self.work_tasks.items()],\n                key=lambda x: x[1].next_run\n            )\n            \n            for task_id, task in upcoming_tasks[:5]:  # Show top 5 upcoming tasks\n                time_remaining = task.next_run - current_time\n                minutes_remaining = int(time_remaining.total_seconds() / 60)\n                print(f\"- {task.name} (ID: {task_id}): dalam {minutes_remaining} menit\")\n        else:\n            print(\"Daily work cycle tidak berjalan.\")\n            \n            # Show tasks even if cycle is not running\n            if self.work_tasks:\n                print(f\"\\nTotal tugas terdaftar: {len(self.work_tasks)}\")\n                print(\"Jalankan 'Start Work Cycle' untuk mulai menjalankan tugas-tugas.\")\n\n    async def add_work_task(self):\n        \"\"\"Add a new task to the work cycle\"\"\"\n        name = await ainput(\"Nama tugas: \")\n        \n        print(\"\\nJenis aksi:\")\n        print(\"1. Log (Mencatat ke log)\")\n        print(\"2. Notification (Pemberitahuan)\")\n        print(\"3. Command (Menjalankan perintah)\")\n        print(\"4. Status Update (Pembaruan status sistem)\")\n        \n        action_type_choice = await ainput(\"Pilih jenis aksi (1-4): \")\n        action_types = {\n            '1': 'log',\n            '2': 'notification',\n            '3': 'command',\n            '4': 'status_update'\n        }\n        \n        if action_type_choice not in action_types:\n            print(\"Pilihan tidak valid!\")\n            return\n        \n        action_type = action_types[action_type_choice]\n        data = {}\n        \n        # Get task-specific data\n        if action_type == 'log':\n            message = await ainput(\"Pesan log: \")\n            data['message'] = message\n        \n        elif action_type == 'notification':\n            message = await ainput(\"Pesan notifikasi: \")\n            recipients = await ainput(\"Penerima (pisahkan dengan koma): \")\n            data['message'] = message\n            data['recipients'] = [r.strip() for r in recipients.split(',') if r.strip()]\n        \n        elif action_type == 'command':\n            command = await ainput(\"Perintah yang akan dijalankan: \")\n            data['command'] = command\n        \n        # Get interval\n        interval_choice = await ainput(\"Interval waktu (1: 15 menit, 2: 1 jam, 3: 1 hari, 4: Custom): \")\n        \n        if interval_choice == '1':\n            interval_seconds = 900  # 15 minutes\n        elif interval_choice == '2':\n            interval_seconds = 3600  # 1 hour\n        elif interval_choice == '3':\n            interval_seconds = 86400  # 1 day\n        elif interval_choice == '4':\n            interval_minutes = await ainput(\"Masukkan interval dalam menit: \")\n            try:\n                interval_seconds = int(interval_minutes) * 60\n            except ValueError:\n                print(\"Input harus berupa angka!\")\n                return\n        else:\n            print(\"Pilihan tidak valid!\")\n            return\n        \n        # Create task\n        task = WorkCycleTask(\n            name=name,\n            interval_seconds=interval_seconds,\n            action_type=action_type,\n            data=data\n        )\n        \n        # Add randomness to start time to distribute load\n        random_offset = random.randint(0, min(300, interval_seconds // 2))  # max 5 min or half the interval\n        task.next_run = datetime.now() + timedelta(seconds=random_offset)\n        \n        task_id = self.task_id_counter\n        self.work_tasks[task_id] = task\n        self.task_id_counter += 1\n        \n        if self._save_config():\n            print(f\"Tugas '{name}' berhasil ditambahkan dengan ID {task_id}\")\n            print(f\"Tugas akan pertama kali dijalankan pada: {task.next_run.strftime('%Y-%m-%d %H:%M:%S')}\")\n        else:\n            print(f\"Tugas '{name}' ditambahkan tetapi gagal menyimpan konfigurasi.\")\n\n    async def list_work_tasks(self):\n        \"\"\"List all work tasks\"\"\"\n        if not self.work_tasks:\n            print(\"Belum ada tugas terdaftar.\")\n            return\n        \n        print(\"\\nDaftar Tugas Work Cycle:\")\n        current_time = datetime.now()\n        \n        for task_id, task in self.work_tasks.items():\n            time_to_next = task.next_run - current_time\n            minutes_to_next = max(0, int(time_to_next.total_seconds() / 60))\n            \n            print(f\"ID: {task_id} - {task.name}\")\n            print(f\"  Jenis: {task.action_type}\")\n            print(f\"  Interval: {task.interval_seconds // 60} menit\")\n            print(f\"  Dijalankan selanjutnya dalam: {minutes_to_next} menit\")\n            print(f\"  Total dijalankan: {task.total_runs} kali\")\n            if task.last_run:\n                print(f\"  Terakhir dijalankan: {task.last_run.strftime('%Y-%m-%d %H:%M:%S')}\")\n            print()\n\n    async def delete_work_task(self):\n        \"\"\"Delete a work task\"\"\"\n        await self.list_work_tasks()\n        task_id_input = await ainput(\"Masukkan ID tugas yang akan dihapus: \")\n        \n        try:\n            task_id = int(task_id_input)\n            if task_id in self.work_tasks:\n                task_name = self.work_tasks[task_id].name\n                del self.work_tasks[task_id]\n                \n                if self._save_config():\n                    print(f\"Tugas '{task_name}' dengan ID {task_id} berhasil dihapus.\")\n                else:\n                    print(f\"Tugas '{task_name}' dihapus tetapi gagal menyimpan konfigurasi.\")\n            else:\n                print(f\"Tugas dengan ID {task_id} tidak ditemukan.\")\n        except ValueError:\n            print(\"Input harus berupa angka!\")", "ui\\__init__.py": "# ui/__init__.py\nfrom .main_menu import MainMenu\nfrom .account_management import AccountManagement\nfrom .auto_responder import AutoResponderMenu\nfrom .task_scheduling import TaskSchedulingMenu\nfrom .work_cycle import WorkCycleMenu\nfrom .analytics import AnalyticsMenu\nfrom .status import StatusMenu", "utils\\helpers.py": "# utils/helpers.py\nimport os\nimport logging\nfrom datetime import datetime\n\ndef setup_logging():\n    \"\"\"Mengatur konfigurasi logging.\"\"\"\n    os.makedirs('logs', exist_ok=True)\n    log_file = f\"logs/{datetime.now().strftime('%Y-%m-%d')}.log\"\n    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s',\n                        handlers=[logging.FileHandler(log_file), logging.StreamHandler()])", "utils\\__init__.py": "# utils/__init__.py\nfrom .helpers import setup_logging"}}