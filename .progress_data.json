{"hashes": {"core.py": "77b3c02cbb92e291a1f6bc410117451e", "main.py": "3a900262f1b1295065b55b62a77e0366", "README.md": "47fd959dd730f744af7e323311ee369d", "responder_rules.json": "eb1d2a9147ad18faa3e30a843b134d88", "db\\database_manager.py": "ae1efdddc3112d7ef39f6c30aa8f672f", "db\\__init__.py": "70f3e4b4c1c2302418b1f8f861731437", "logs\\2025-04-07.log": "d41d8cd98f00b204e9800998ecf8427e", "rules\\rules_manager.py": "5d48f04257dcfd7ad1ac556f3ab2e3d1", "rules\\__init__.py": "9c0dd26b306a1d9e17e631e3caee6b65", "telegram\\client_manager.py": "f6c9ab341a620f289df8dad02858b70e", "telegram\\message_handler.py": "92c1ad345b24ea07bad74c88aa2d19bb", "telegram\\__init__.py": "d78139a96c7cecafaa7993f7ea4ed15d", "ui\\account_management.py": "f44b210b3e3abc32ac9334523e345918", "ui\\analytics.py": "30aac597520c31157f99975378a6cab5", "ui\\auto_responder.py": "cc7ba031e9b203810f823f3f1f4aa747", "ui\\main_menu.py": "8eaf99394c478d1f525c09cfdd2d6e40", "ui\\status.py": "cdd36261e86deb1aee08a295ca59d7c0", "ui\\task_scheduling.py": "94d62b7b4f0daeb27441703c8289f235", "ui\\work_cycle.py": "604f8b66403d01767d6a2dad978ddf32", "ui\\__init__.py": "99227c63b436fa24f54874c19e0b35b3", "utils\\helpers.py": "8b0bb221c0e37e4b4ebb439f0b001cf8", "utils\\__init__.py": "48318b20608a173e2e3bc85326537d51"}, "contents": {"core.py": "# core.py\nclass UnlimitedLoginSystem:\n    def __init__(self):\n        pass # Inisialisasi akan dilakukan di main.py\n\n    async def shutdown(self):\n        pass # Shutdown akan dilakukan di main.py\n\n    async def run_responder(self):\n        \"\"\"Placeholder for background responder tasks\"\"\"\n        pass", "main.py": "# main.py\nimport asyncio\nimport logging\nimport signal\n\nfrom core import UnlimitedLoginSystem\nfrom db.database_manager import DatabaseManager\nfrom telegram.client_manager import ClientManager\nfrom rules.rules_manager import RulesManager\nfrom telegram.message_handler import MessageHandler\nfrom ui import MainMenu, AccountManagement, AutoResponderMenu, TaskSchedulingMenu, WorkCycleMenu, AnalyticsMenu, StatusMenu\nfrom utils.helpers import setup_logging\n\nasync def main():\n    setup_logging()  # Inisialisasi logging\n\n    # Inisialisasi sistem\n    db_manager = DatabaseManager()\n    client_manager = ClientManager()\n    rules_manager = RulesManager()\n    message_handler = MessageHandler(rules_manager)\n    system = UnlimitedLoginSystem() # Meskipun minimal, instance tetap dibuat\n\n    # Membuat instance dari setiap menu UI\n    account_manager = AccountManagement(db_manager, client_manager)\n    auto_responder_menu = AutoResponderMenu(rules_manager, client_manager, message_handler, db_manager)\n    task_scheduling_menu = TaskSchedulingMenu()\n    work_cycle_menu = WorkCycleMenu()\n    analytics_menu = AnalyticsMenu(db_manager, client_manager)\n    status_menu = StatusMenu(db_manager, client_manager)\n\n    # Membuat instance dari MainMenu dan memberikan dependensi\n    ui = MainMenu(account_manager, auto_responder_menu, task_scheduling_menu,\n                  work_cycle_menu, analytics_menu, status_menu)\n\n    loop = asyncio.get_event_loop()\n\n    async def shutdown():\n        await client_manager.disconnect_all_clients()\n        db_manager._close_connection()\n        logging.info(\"Program shutdown complete\")\n\n    def shutdown_handler(signame):\n        logging.info(f\"Received signal {signame}. Shutting down...\")\n        asyncio.create_task(shutdown())\n        loop.stop()\n\n    for signame in ('SIGINT', 'SIGTERM'):\n        try:\n            loop.add_signal_handler(getattr(signal, signame), lambda: shutdown_handler(signame))\n        except NotImplementedError:\n            pass\n\n    try:\n        await ui.display_main_menu()\n    except asyncio.CancelledError:\n        logging.info(\"Program canceled\")\n    except KeyboardInterrupt:\n        logging.info(\"Program interrupted by user\")\n    except Exception as e:\n        logging.error(f\"Unexpected error: {str(e)}\", exc_info=True)\n    finally:\n        await shutdown()\n        logging.info(\"Program shutdown complete\")\n\nif __name__ == \"__main__\":\n    try:\n        asyncio.run(main())\n    except KeyboardInterrupt:\n        logging.info(\"Program interrupted by user\")\n    except Exception as e:\n        logging.error(f\"Fatal error: {str(e)}\", exc_info=True)", "README.md": "# Sistem Login Unlimited Telethon \n\nSistem Login Unlimited Telethon adalah aplikasi untuk mengelola banyak akun Telegram dalam satu sistem terpusat. Fitur utama meliputi:\n\n- Pengelolaan Akun: Tambah, hapus, perbarui, ekspor dan impor akun Telegram. \n- Uji Koneksi: Tes koneksi akun dan perbaiki otomatis jika gagal.\n- Auto Responder: Balas pesan secara otomatis berdasarkan aturan yang ditentukan.\n- Penjadwalan Tugas: Sistem untuk menjadwalkan tugas untuk eksekusi tunda. \n- Analitik: Mengekspor analitik harian, mingguan, dan bulanan.\n- Siklus Kerja: Menjalankan tugas berulang secara periodik.\n- Status Sistem: Lihat status sistem terkini seperti uptime dan jumlah akun aktif.\n\n## Persyaratan Sistem\n\n- Python 3.6+\n- Telethon\n- aioconsole \n- sqlite3\n- prettytable\n\n## Cara Menjalankan\n\n1. Instal dependensi: `pip install -r requirements.txt`\n2. Jalankan aplikasi: `python main.py`\n3. Ikuti instruksi di menu untuk mengelola sistem.\n\n## Struktur Folder\n\n- `core.py`: Inti sistem, menginisialisasi dan menghentikan komponen. \n- `db/`: Manajer database untuk penyimpanan akun.\n- `rules/`: Manajer aturan untuk auto responder.\n- `telegram/`: Manajer client Telegram dan handler pesan.\n- `ui/`: Antarmuka pengguna berbasis teks untuk semua fitur.\n- `utils/`: Fungsi pembantu umum.\n- `main.py`: Titik masuk aplikasi utama.\n\n## Kontribusi\n\nKontribusi, laporan masalah, dan permintaan fitur selalu diterima! Silakan buka issue atau PR jika Anda ingin berkontribusi.\n", "responder_rules.json": "{\n    \"1\": {\n        \"keyword\": \"NOTIFIKASI PROFIT\",\n        \"responses\": [\n            \"Dulu cuma penasaran, sekarang malah jadi penghasilan tetap tiap minggu.\",\n            \"Udah beberapa kali narik profit, semua masuk lancar tanpa kendala.\",\n            \"Investasi pertama yang bener-bener kasih hasil nyata tanpa ribet.\",\n            \"Pokoknya puas banget! JTrade bukan kaleng-kaleng!\"\n        ],\n        \"private_only\": false\n    }\n}", "db\\database_manager.py": "# db/database_manager.py\nimport os\nimport sqlite3\nimport logging\nimport time\n\nclass DatabaseManager:\n    def __init__(self, db_path='accounts/accounts.db'):\n        self.db_path = db_path\n        self._setup_folders()\n        self.conn = None\n        self.cursor = None\n        self._setup_database()\n    \n    def _setup_folders(self):\n        os.makedirs('accounts', exist_ok=True)\n    \n    def _setup_database(self):\n        max_retries = 3\n        retry_delay = 1\n        for attempt in range(max_retries):\n            try:\n                self._close_connection()\n                self.conn = sqlite3.connect(self.db_path)\n                self.cursor = self.conn.cursor()\n                \n                # Cek apakah tabel sudah ada\n                self.cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name='accounts'\")\n                table_exists = self.cursor.fetchone()\n                \n                if not table_exists:\n                    # Buat tabel baru dengan id sebagai PRIMARY KEY autoincrement\n                    self.cursor.execute('''CREATE TABLE accounts(\n                        id INTEGER PRIMARY KEY AUTOINCREMENT,\n                        api_id INTEGER NOT NULL, \n                        api_hash TEXT, \n                        phone TEXT UNIQUE, \n                        twofa TEXT, \n                        user_id INTEGER, \n                        username TEXT, \n                        name TEXT)''')\n                else:\n                    # Cek struktur tabel yang ada\n                    self.cursor.execute(\"PRAGMA table_info(accounts)\")\n                    columns = [column[1] for column in self.cursor.fetchall()]\n                    \n                    # Jika tabel lama (tanpa kolom id), migrasi ke struktur baru\n                    if \"id\" not in columns:\n                        self.cursor.execute(\"ALTER TABLE accounts RENAME TO accounts_old\")\n                        self.cursor.execute('''CREATE TABLE accounts(\n                            id INTEGER PRIMARY KEY AUTOINCREMENT,\n                            api_id INTEGER NOT NULL, \n                            api_hash TEXT, \n                            phone TEXT UNIQUE, \n                            twofa TEXT, \n                            user_id INTEGER, \n                            username TEXT, \n                            name TEXT)''')\n                        self.cursor.execute('''INSERT INTO accounts \n                            (api_id, api_hash, phone, twofa, user_id, username, name)\n                            SELECT api_id, api_hash, phone, twofa, user_id, username, name \n                            FROM accounts_old''')\n                        self.cursor.execute(\"DROP TABLE accounts_old\")\n                        logging.info(\"Database berhasil dimigrasi ke struktur baru\")\n                \n                self.conn.commit()\n                logging.debug(\"Database connection established successfully\")\n                return\n            except sqlite3.Error as e:\n                logging.error(f\"Database connection error (attempt {attempt+1}/{max_retries}): {str(e)}\")\n                if attempt < max_retries - 1:\n                    time.sleep(retry_delay)\n                    retry_delay *= 2\n                else:\n                    logging.critical(\"Failed to connect to database after multiple attempts\")\n                    raise\n    \n    def _close_connection(self):\n        if self.conn:\n            try:\n                self.conn.close()\n                self.conn = None\n                self.cursor = None\n                logging.debug(\"Database connection closed\")\n            except sqlite3.Error as e:\n                logging.error(f\"Error closing database connection: {str(e)}\")\n    \n    def get_connection(self):\n        if not self.conn:\n            self._setup_database()\n        return self.conn, self.cursor\n    \n    def execute_query(self, query, params=(), fetch_all=False, commit=False):\n        max_retries = 3\n        retry_delay = 1\n        for attempt in range(max_retries):\n            try:\n                if not self.conn:\n                    self._setup_database()\n                self.cursor.execute(query, params)\n                if commit:\n                    self.conn.commit()\n                if fetch_all:\n                    return self.cursor.fetchall()\n                return True\n            except sqlite3.Error as e:\n                logging.error(f\"Database query error (attempt {attempt+1}/{max_retries}): {str(e)}\")\n                if \"database is locked\" in str(e) and attempt < max_retries - 1:\n                    time.sleep(retry_delay)\n                    retry_delay *= 2\n                    self._setup_database()\n                else:\n                    logging.error(\"Failed to execute query after retries\")\n                    raise\n        return False\n    \n    def get_all_accounts(self):\n        return self.execute_query(\"SELECT api_id, api_hash, phone, twofa, user_id, username, name FROM accounts\", fetch_all=True)\n    \n    def get_account_by_api_id(self, api_id):\n        accounts = self.execute_query(\"SELECT api_id, api_hash, phone, twofa, user_id, username, name FROM accounts WHERE api_id=?\", (api_id,), fetch_all=True)\n        return accounts[0] if accounts else None\n    \n    def add_account(self, api_id, api_hash, phone, twofa, user_id, username, name):\n        try:\n            result = self.execute_query(\n                \"INSERT OR IGNORE INTO accounts (api_id, api_hash, phone, twofa, user_id, username, name) VALUES (?,?,?,?,?,?,?)\",\n                (api_id, api_hash, phone, twofa, user_id, username, name),\n                commit=True\n            )\n            if self.cursor.rowcount == 0:\n                result = self.execute_query(\n                    \"UPDATE accounts SET api_id=?, api_hash=?, twofa=?, user_id=?, username=?, name=? WHERE phone=?\",\n                    (api_id, api_hash, twofa, user_id, username, name, phone),\n                    commit=True\n                )\n            return result\n        except sqlite3.IntegrityError as e:\n            logging.warning(f\"Constraint violation adding account {phone}: {str(e)}\")\n            return False\n    \n    def update_account(self, api_id, user_id, username, name):\n        return self.execute_query(\n            \"UPDATE accounts SET user_id=?, username=?, name=? WHERE api_id=?\", \n            (user_id, username, name, api_id), \n            commit=True\n        )\n    \n    def delete_account(self, api_id):\n        return self.execute_query(\"DELETE FROM accounts WHERE api_id=?\", (api_id,), commit=True)\n\n    def count_accounts(self):\n        result = self.execute_query(\"SELECT COUNT(*) FROM accounts\", fetch_all=True)\n        return result[0][0] if result else 0", "db\\__init__.py": "# db/__init__.py\nfrom .database_manager import DatabaseManager", "logs\\2025-04-07.log": "", "rules\\rules_manager.py": "# rules/rules_manager.py\nimport os\nimport logging\nimport json\nimport random\n\nclass RulesManager:\n    def __init__(self, rules_file='responder_rules.json'):\n        self.rules_file = rules_file\n        self.rules = {}\n        self._load_rules()\n    def _load_rules(self):\n        if os.path.exists(self.rules_file):\n            try:\n                with open(self.rules_file, 'r', encoding='utf-8') as f:\n                    self.rules = json.load(f)\n                self._migrate_rules_format()\n            except Exception as e:\n                logging.error(f\"Error loading rules: {str(e)}\")\n                self.rules = {}\n        else:\n            self.rules = {}\n            self._save_rules()\n    def _migrate_rules_format(self):\n        changed = False\n        for rule_id, rule in self.rules.items():\n            if isinstance(rule.get('response'), str):\n                rule['responses'] = [rule['response']]\n                del rule['response']\n                changed = True\n        if changed:\n            self._save_rules()\n            logging.info(\"Rules migrated to support multiple responses\")\n    def _save_rules(self):\n        try:\n            with open(self.rules_file, 'w', encoding='utf-8') as f:\n                json.dump(self.rules, f, indent=4)\n            logging.debug(\"Rules saved successfully\")\n            return True\n        except Exception as e:\n            logging.error(f\"Error saving rules: {str(e)}\")\n            return False\n    def get_all_rules(self):\n        return self.rules\n    def get_rule(self, rule_id):\n        return self.rules.get(rule_id)\n    def add_rule(self, keyword, response, private_only=False):\n        if not keyword.strip() or not response.strip():\n            return False, \"Kata kunci dan pesan balasan tidak boleh kosong!\"\n        rule_id = str(len(self.rules) + 1)\n        self.rules[rule_id] = {'keyword': keyword, 'responses': [response], 'private_only': private_only}\n        saved = self._save_rules()\n        return saved, f\"Aturan dengan ID {rule_id} berhasil ditambahkan!\" if saved else \"Gagal menyimpan aturan!\"\n    def update_rule(self, rule_id, keyword=None, response=None, private_only=None):\n        if rule_id not in self.rules:\n            return False, f\"Aturan dengan ID {rule_id} tidak ditemukan!\"\n        rule = self.rules[rule_id]\n        if keyword is not None and keyword.strip():\n            rule['keyword'] = keyword\n        if response is not None and response.strip():\n            if 'responses' not in rule:\n                rule['responses'] = []\n            rule['responses'].append(response)\n        if private_only is not None:\n            rule['private_only'] = private_only\n        saved = self._save_rules()\n        return saved, f\"Aturan dengan ID {rule_id} berhasil diperbarui!\" if saved else \"Gagal menyimpan aturan!\"\n    def delete_rule(self, rule_id):\n        if rule_id not in self.rules:\n            return False, f\"Aturan dengan ID {rule_id} tidak ditemukan!\"\n        del self.rules[rule_id]\n        saved = self._save_rules()\n        return saved, f\"Aturan dengan ID {rule_id} berhasil dihapus!\" if saved else \"Gagal menghapus aturan!\"\n    def delete_response(self, rule_id, response_index):\n        if rule_id not in self.rules:\n            return False, f\"Aturan dengan ID {rule_id} tidak ditemukan!\"\n        rule = self.rules[rule_id]\n        if 'responses' not in rule or not isinstance(rule['responses'], list):\n            return False, \"Format aturan tidak valid!\"\n        if response_index < 0 or response_index >= len(rule['responses']):\n            return False, f\"Indeks respons {response_index} tidak valid!\"\n        del rule['responses'][response_index]\n        if not rule['responses']:\n            rule['responses'] = [\"Default response\"]\n        saved = self._save_rules()\n        return saved, f\"Respons pada indeks {response_index} berhasil dihapus!\" if saved else \"Gagal menghapus respons!\"\n    def get_random_response(self, rule_id):\n        rule = self.rules.get(rule_id)\n        if not rule:\n            return None\n        responses = rule.get('responses', [])\n        if not responses and 'response' in rule:\n            return rule['response']\n        if not responses:\n            return None\n        return random.choice(responses)\n    def export_rules(self, filename=\"responder_rules_export.json\"):\n        if not self.rules:\n            return False, \"Tidak ada aturan yang dapat diekspor.\"\n        try:\n            with open(filename, 'w', encoding='utf-8') as f:\n                json.dump(self.rules, f, indent=4)\n            return True, f\"Berhasil mengekspor {len(self.rules)} aturan ke {filename}\"\n        except Exception as e:\n            logging.error(f\"Gagal mengekspor aturan: {str(e)}\")\n            return False, f\"Gagal mengekspor aturan: {str(e)}\"\n    def import_rules(self, filename=\"responder_rules_export.json\", replace=False):\n        if not os.path.exists(filename):\n            return False, f\"File {filename} tidak ditemukan!\"\n        try:\n            with open(filename, 'r', encoding='utf-8') as f:\n                imported_rules = json.load(f)\n            if not imported_rules:\n                return False, \"Tidak ada aturan yang dapat diimpor.\"\n            for rule_id, rule in imported_rules.items():\n                if 'response' in rule and 'responses' not in rule:\n                    rule['responses'] = [rule['response']]\n                    del rule['response']\n            if replace:\n                self.rules = imported_rules\n            else:\n                highest_id = 0\n                for rule_id in self.rules:\n                    try:\n                        rule_id_int = int(rule_id)\n                        if rule_id_int > highest_id:\n                            highest_id = rule_id_int\n                    except ValueError:\n                        pass\n                for rule_id, rule in imported_rules.items():\n                    if rule_id not in self.rules:\n                        self.rules[rule_id] = rule\n                    else:\n                        highest_id += 1\n                        self.rules[str(highest_id)] = rule\n            saved = self._save_rules()\n            return saved, f\"Berhasil mengimpor aturan. Total aturan saat ini: {len(self.rules)}\"\n        except Exception as e:\n            logging.error(f\"Gagal mengimpor aturan: {str(e)}\")\n            return False, f\"Gagal mengimpor aturan: {str(e)}\"", "rules\\__init__.py": "# rules/__init__.py\nfrom .rules_manager import RulesManager", "telegram\\client_manager.py": "# telegram/client_manager.py\nimport os\nimport logging\n\nfrom telethon import TelegramClient\nfrom telethon.errors import SessionPasswordNeededError, RPCError\n\nclass ClientManager:\n    def __init__(self):\n        self.active_clients = {}\n        os.makedirs('session', exist_ok=True)\n    async def create_client(self, api_id, api_hash, phone, default_2fa=None):\n        client = None\n        try:\n            client = TelegramClient(f'session/{phone}', api_id, api_hash)\n            await client.connect()\n            return client\n        except Exception as e:\n            logging.error(f\"Error creating client for {phone}: {str(e)}\")\n            if client and client.is_connected():\n                await client.disconnect()\n            raise\n    async def authorize_client(self, client, phone, default_2fa=None, code_callback=None):\n        try:\n            if not await client.is_user_authorized():\n                try:\n                    await client.send_code_request(phone)\n                    code = await code_callback() if code_callback else input(\"Masukkan kode yang diterima: \")\n                    await client.sign_in(phone, code)\n                except SessionPasswordNeededError:\n                    if default_2fa:\n                        await client.sign_in(password=default_2fa)\n                    else:\n                        password = input(\"Masukkan password 2FA: \")\n                        await client.sign_in(password=password)\n            me = await client.get_me()\n            return me\n        except Exception as e:\n            logging.error(f\"Error authorizing client for {phone}: {str(e)}\")\n            raise\n    async def test_connection(self, client, phone):\n        try:\n            if not client.is_connected():\n                await client.connect()\n            is_authorized = await client.is_user_authorized()\n            return {'phone': phone, 'status': 'Berhasil' if is_authorized else 'Gagal', 'error': None}\n        except RPCError as e:\n            return {'phone': phone, 'status': 'Gagal', 'error': str(e)}\n        except Exception as e:\n            return {'phone': phone, 'status': 'Error', 'error': str(e)}\n    def add_active_client(self, phone, client):\n        self.active_clients[phone] = client\n    def remove_active_client(self, phone):\n        if phone in self.active_clients:\n            del self.active_clients[phone]\n    async def disconnect_client(self, phone):\n        if phone in self.active_clients:\n            client = self.active_clients[phone]\n            if client and client.is_connected():\n                await client.disconnect()\n            self.remove_active_client(phone)\n            return True\n        return False\n    async def disconnect_all_clients(self):\n        for phone, client in list(self.active_clients.items()):\n            try:\n                if client and client.is_connected():\n                    await client.disconnect()\n            except Exception as e:\n                logging.error(f\"Error disconnecting client {phone}: {str(e)}\")\n            finally:\n                self.remove_active_client(phone)", "telegram\\message_handler.py": "# telegram/message_handler.py\nimport asyncio\nimport logging\nimport time\nimport random\n\nfrom telethon import events\n\nclass MessageHandler:\n    def __init__(self, rules_manager):\n        self.rules_manager = rules_manager\n        self.message_queues = {}\n        self.handlers = {}\n        self.delays = {}\n        self.last_responses = {}\n        self.last_response_times = {}\n    def setup_handler(self, client, phone, delay_seconds=0.5):\n        self.delays[phone] = delay_seconds\n        self.last_responses[phone] = {}\n        self.last_response_times[phone] = time.time()\n        self.message_queues[phone] = asyncio.Queue()\n        @client.on(events.NewMessage)\n        async def handle_new_message(event):\n            try:\n                if not hasattr(event, 'message') or not hasattr(event.message, 'text'):\n                    return\n                message_text = event.message.text\n                if not message_text:\n                    return\n                is_private = event.is_private\n                should_respond = False\n                rule_matched = None\n                for rule_id, rule in self.rules_manager.get_all_rules().items():\n                    private_only = rule.get('private_only', False)\n                    if private_only and not is_private:\n                        continue\n                    if rule['keyword'].lower() in message_text.lower():\n                        should_respond = True\n                        rule_matched = rule_id\n                        all_responses = rule.get('responses', [])\n                        if not all_responses and 'response' in rule:\n                            all_responses = [rule['response']]\n                        if len(all_responses) <= 1:\n                            response_text = all_responses[0] if all_responses else \"\"\n                        else:\n                            recent_responses = self.last_responses.get(phone, {}).get(rule_id, [])\n                            available_responses = [r for r in all_responses if r not in recent_responses]\n                            if not available_responses:\n                                available_responses = all_responses\n                            response_text = random.choice(available_responses)\n                            if rule_id not in self.last_responses.get(phone, {}):\n                                self.last_responses[phone][rule_id] = []\n                            self.last_responses[phone][rule_id].append(response_text)\n                            if len(self.last_responses[phone][rule_id]) > 2:\n                                self.last_responses[phone][rule_id].pop(0)\n                        break\n                if should_respond and rule_matched and response_text:\n                    current_time = time.time()\n                    time_since_last = current_time - self.last_response_times.get(phone, 0)\n                    extra_delay = 0\n                    if time_since_last < 30:\n                        extra_delay = random.uniform(10, 40)\n                    await self.message_queues[phone].put({'event': event, 'response': response_text, 'rule_id': rule_matched, 'extra_delay': extra_delay})\n            except Exception as e:\n                logging.error(f\"Error handling message: {str(e)}\")\n        self.handlers[phone] = handle_new_message\n        asyncio.create_task(self._process_message_queue(phone))\n    async def _process_message_queue(self, phone):\n        if phone not in self.message_queues:\n            return\n        queue = self.message_queues[phone]\n        base_delay_seconds = self.delays.get(phone, 0.5)\n        while phone in self.message_queues:\n            try:\n                try:\n                    item = await asyncio.wait_for(queue.get(), timeout=1.0)\n                except asyncio.TimeoutError:\n                    continue\n                event = item['event']\n                response = item['response']\n                rule_id = item['rule_id']\n                extra_delay = item.get('extra_delay', 0)\n                delay_variation = random.uniform(0.5, 1.5)\n                actual_delay = base_delay_seconds * delay_variation + extra_delay\n                logging.info(f\"Phone {phone}: Waiting {actual_delay:.2f}s before responding (base: {base_delay_seconds:.2f}s, extra: {extra_delay:.2f}s)\")\n                await asyncio.sleep(actual_delay)\n                typing_duration = min(len(response) / 5, 10)\n                typing_duration *= random.uniform(0.8, 1.2)\n                async with event.client.action(event.chat_id, 'typing'):\n                    await asyncio.sleep(typing_duration)\n                await asyncio.sleep(0.5)\n                await event.respond(response)\n                logging.info(f\"Auto respond to {event.sender_id} with rule {rule_id} (delay: {actual_delay:.2f}s, typing: {typing_duration:.2f}s)\")\n                self.last_response_times[phone] = time.time()\n                queue.task_done()\n            except asyncio.CancelledError:\n                break\n            except Exception as e:\n                logging.error(f\"Error processing message queue: {str(e)}\")\n                await asyncio.sleep(1)\n    def remove_handler(self, phone):\n        if phone in self.handlers:\n            del self.handlers[phone]\n        if phone in self.message_queues:\n            del self.message_queues[phone]\n        if phone in self.delays:\n            del self.delays[phone]\n        if phone in self.last_responses:\n            del self.last_responses[phone]\n        if phone in self.last_response_times:\n            del self.last_response_times[phone]", "telegram\\__init__.py": "# telegram/__init__.py\nfrom .client_manager import ClientManager\nfrom .message_handler import MessageHandler", "ui\\account_management.py": "# ui/account_management.py\nimport asyncio\nimport logging\nimport json  # Tambahkan baris ini\n\nfrom aioconsole import ainput\nfrom prettytable import PrettyTable\n\nclass AccountManagement:\n    def __init__(self, db_manager, client_manager):\n        self.db_manager = db_manager\n        self.client_manager = client_manager\n\n    async def add_account(self):\n        \"\"\"UI for adding a new account\"\"\"\n        try:\n            api_id = await ainput(\"Masukkan API ID: \")\n            api_hash = await ainput(\"Masukkan API HASH: \")\n            phone = await ainput(\"Masukkan nomor telepon: \")\n\n            if not api_id.strip() or not api_hash.strip() or not phone.strip():\n                print(\"Semua field harus diisi!\")\n                return\n\n            client = await self.client_manager.create_client(int(api_id), api_hash, phone)\n\n            async def code_callback():\n                return await ainput(\"Masukkan kode yang diterima: \")\n\n            me = await self.client_manager.authorize_client(client, phone,\n                                                            default_2fa=\"Dgvt61zwe@\",\n                                                            code_callback=code_callback)\n\n            self.db_manager.add_account(api_id, api_hash, phone, \"Dgvt61zwe@\",\n                                     me.id, me.username, me.first_name)\n\n            print(f\"Akun {phone} berhasil ditambahkan!\")\n            await client.disconnect()\n        except Exception as e:\n            logging.error(f\"Gagal menambahkan akun: {str(e)}\")\n            print(f\"Gagal menambahkan akun: {str(e)}\")\n\n    def list_accounts(self):\n        \"\"\"UI for listing all accounts with pagination support\"\"\"\n        table = PrettyTable()\n        table.field_names = [\"API ID\", \"Phone\", \"User ID\", \"Username\", \"Name\"]\n\n        try:\n            accounts = self.db_manager.get_all_accounts()\n            if not accounts:\n                print(\"Tidak ada akun yang tersimpan.\")\n                return\n            for row in accounts:\n                table.add_row([row[0], row[2], row[4], row[5], row[6]])\n            print(table)\n        except Exception as e:\n            logging.error(f\"Gagal menampilkan tabel: {str(e)}\")\n            print(f\"Gagal menampilkan tabel: {str(e)}\")\n\n    async def test_connection(self):\n        \"\"\"UI for testing account connections with auto-fix for failed accounts\"\"\"\n        try:\n            api_id = await ainput(\"Masukkan API ID (kosongkan untuk semua): \")\n            accounts = []\n            if api_id.strip():\n                account = self.db_manager.get_account_by_api_id(api_id)\n                if account:\n                    accounts = [account]\n            else:\n                accounts = self.db_manager.get_all_accounts()\n            if not accounts:\n                print(\"Tidak ada akun yang ditemukan!\")\n                return\n            results = {}\n            failed_accounts = []\n            for account in accounts:\n                api_id, api_hash, phone = account[0], account[1], account[2]\n                client = await self.client_manager.create_client(api_id, api_hash, phone)\n                result = await self.client_manager.test_connection(client, phone)\n                results[api_id] = result\n                if result['status'] != 'Berhasil':\n                    failed_accounts.append(account)\n                else:\n                    await client.disconnect()\n            print(\"Hasil uji koneksi:\")\n            for api_id, info in results.items():\n                status = info['status']\n                phone = info['phone']\n                error = info['error']\n                print(f\"- {phone} (API ID: {api_id}): {status}\")\n                if error:\n                    print(f\"  Error: {error}\")\n            if failed_accounts:\n                fix_all = await ainput(\"\\nAda akun yang gagal. Perbaiki semua? (y/n): \")\n                if fix_all.lower() == 'y':\n                    for account in failed_accounts:\n                        await self._fix_failed_account(account)\n                else:\n                    for i, account in enumerate(failed_accounts, 1):\n                        print(f\"{i}. {account[2]} (API ID: {account[0]})\")\n                    choice = await ainput(\"Pilih nomor akun yang akan diperbaiki (0 untuk batal): \")\n                    if choice != '0':\n                        try:\n                            idx = int(choice) - 1\n                            if 0 <= idx < len(failed_accounts):\n                                await self._fix_failed_account(failed_accounts[idx])\n                            else:\n                                print(\"Pilihan tidak valid!\")\n                        except ValueError:\n                            print(\"Input harus berupa angka!\")\n        except Exception as e:\n            logging.error(f\"Error during connection test: {str(e)}\")\n            print(f\"Gagal melakukan uji koneksi: {str(e)}\")\n\n    async def _fix_failed_account(self, account):\n        \"\"\"Fix a failed account by requesting new code and saving session\"\"\"\n        try:\n            from telethon.errors import SessionPasswordNeededError\n            api_id, api_hash, phone, twofa = account[0], account[1], account[2], account[3]\n            print(f\"\\nMemperbaiki akun {phone}...\")\n            client = await self.client_manager.create_client(int(api_id), api_hash, phone)\n            if not await client.is_user_authorized():\n                try:\n                    await client.send_code_request(phone)\n                    code = await ainput(\"Masukkan kode Telegram yang diterima: \")\n                    try:\n                        await client.sign_in(phone, code)\n                    except SessionPasswordNeededError:\n                        if twofa:\n                            await client.sign_in(password=twofa)\n                        else:\n                            password = await ainput(\"Masukkan password 2FA: \")\n                            await client.sign_in(password=password)\n                            self.db_manager.execute_query(\n                                \"UPDATE accounts SET twofa=? WHERE api_id=?\",\n                                (password, api_id),\n                                commit=True\n                            )\n                    me = await client.get_me()\n                    self.db_manager.update_account(api_id, me.id, me.username, me.first_name)\n                    print(f\"Akun {phone} berhasil diperbaiki dan diperbarui!\")\n                except Exception as e:\n                    logging.error(f\"Gagal memperbaiki akun {phone}: {str(e)}\")\n                    print(f\"Gagal memperbaiki akun {phone}: {str(e)}\")\n            else:\n                print(f\"Akun {phone} sudah terotorisasi.\")\n                me = await client.get_me()\n                self.db_manager.update_account(api_id, me.id, me.username, me.first_name)\n                print(f\"Info akun {phone} berhasil diperbarui!\")\n            await client.disconnect()\n        except Exception as e:\n            logging.error(f\"Gagal memperbaiki akun: {str(e)}\")\n            print(f\"Gagal memperbaiki akun: {str(e)}\")\n\n    async def delete_account(self):\n        \"\"\"UI for deleting an account\"\"\"\n        try:\n            api_id = await ainput(\"Masukkan API ID: \")\n            if not api_id.strip():\n                print(\"API ID tidak boleh kosong!\")\n                return\n            result = self.db_manager.delete_account(api_id)\n            if result:\n                print(f\"Akun {api_id} berhasil dihapus!\")\n            else:\n                print(f\"Gagal menghapus akun {api_id}!\")\n        except Exception as e:\n            logging.error(f\"Gagal menghapus akun: {str(e)}\")\n            print(f\"Gagal menghapus akun: {str(e)}\")\n\n    async def update_account(self):\n        \"\"\"UI for updating account information\"\"\"\n        try:\n            api_id = await ainput(\"Masukkan API ID yang akan diupdate: \")\n            if not api_id.strip():\n                print(\"API ID tidak boleh kosong!\")\n                return\n            account = self.db_manager.get_account_by_api_id(api_id)\n            if not account:\n                print(f\"Akun dengan API ID {api_id} tidak ditemukan!\")\n                return\n            api_id, api_hash, phone = account[0], account[1], account[2]\n            client = await self.client_manager.create_client(int(api_id), api_hash, phone)\n            me = await self.client_manager.authorize_client(client, phone, default_2fa=\"Dgvt61zwe@\")\n            self.db_manager.update_account(api_id, me.id, me.username, me.first_name)\n            await client.disconnect()\n            print(f\"Akun {phone} berhasil diperbarui!\")\n        except Exception as e:\n            logging.error(f\"Gagal memperbarui akun: {str(e)}\")\n            print(f\"Gagal memperbarui akun: {str(e)}\")\n\n    async def export_accounts(self):\n        \"\"\"UI for exporting accounts with verification\"\"\"\n        try:\n            filename = await ainput(\"Masukkan nama file (default: accounts_export.json): \")\n            if not filename.strip():\n                filename = \"accounts_export.json\"\n\n            accounts = self.db_manager.get_all_accounts()\n            if not accounts:\n                print(\"Tidak ada akun untuk diekspor.\")\n                return\n\n            account_list = []\n            for row in accounts:\n                api_id, api_hash, phone, twofa, user_id, username, name = row\n                account_list.append({\n                    \"api_id\": api_id,\n                    \"api_hash\": api_hash,\n                    \"phone\": phone,\n                    \"twofa\": twofa,\n                    \"user_id\": user_id,\n                    \"username\": username,\n                    \"name\": name\n                })\n\n            total_accounts = self.db_manager.count_accounts()\n            if len(account_list) != total_accounts:\n                print(f\"PERINGATAN: Jumlah akun yang diekspor ({len(account_list)}) tidak sesuai dengan jumlah akun di database ({total_accounts})\")\n                proceed = await ainput(\"Tetap lanjutkan ekspor? (y/n): \")\n                if proceed.lower() != 'y':\n                    print(\"Export dibatalkan.\")\n                    return\n\n            with open(filename, 'w', encoding='utf-8') as f:\n                json.dump(account_list, f, indent=4)\n\n            print(f\"Berhasil mengekspor {len(account_list)} akun ke {filename}\")\n\n            try:\n                with open(filename, 'r', encoding='utf-8') as f:\n                    verified_accounts = json.load(f)\n                if len(verified_accounts) == len(account_list):\n                    print(\"Verifikasi file berhasil: Jumlah akun yang diekspor sesuai.\")\n                else:\n                    print(f\"PERINGATAN: Verifikasi file gagal! File berisi {len(verified_accounts)} akun, seharusnya {len(account_list)}.\")\n            except Exception as e:\n                print(f\"Gagal memverifikasi file ekspor: {str(e)}\")\n\n        except Exception as e:\n            logging.error(f\"Gagal mengekspor akun: {str(e)}\")\n            print(f\"Gagal mengekspor akun: {str(e)}\")\n\n    async def import_accounts(self):\n        \"\"\"UI for importing accounts with improved tracking\"\"\"\n        try:\n            import os\n            filename = await ainput(\"Masukkan nama file (default: accounts_export.json): \")\n            if not filename.strip():\n                filename = \"accounts_export.json\"\n            if not os.path.exists(filename):\n                print(f\"File {filename} tidak ditemukan!\")\n                return\n\n            with open(filename, 'r', encoding='utf-8') as f:\n                accounts = json.load(f)\n\n            if not accounts:\n                print(\"Tidak ada akun untuk diimpor.\")\n                return\n\n            accounts_before = self.db_manager.count_accounts()\n\n            success_count = 0\n            fail_count = 0\n            skip_count = 0\n\n            if isinstance(accounts, dict):\n                accounts_list = []\n                for api_id, account_data in accounts.items():\n                    account_data['api_id'] = api_id\n                    accounts_list.append(account_data)\n                accounts = accounts_list\n\n            processed_phones = set()\n\n            for account in accounts:\n                try:\n                    api_id = int(account[\"api_id\"]) if isinstance(account[\"api_id\"], str) else account[\"api_id\"]\n                    api_hash = account.get(\"api_hash\", \"\")\n                    phone = account.get(\"phone\", \"\")\n\n                    if not phone or phone in processed_phones:\n                        skip_count += 1\n                        logging.warning(f\"Melewati akun dengan phone {phone} (kosong atau duplikat)\")\n                        continue\n\n                    twofa = account.get(\"twofa\", \"Dgvt61zwe@\")\n                    user_id = account.get(\"user_id\", 0)\n                    username = account.get(\"username\", None)\n                    name = account.get(\"name\", \"auto\")\n\n                    result = self.db_manager.add_account(\n                        api_id, api_hash, phone, twofa,\n                        user_id, username, name\n                    )\n\n                    if result:\n                        success_count += 1\n                        processed_phones.add(phone)\n                    else:\n                        fail_count += 1\n                        logging.warning(f\"Gagal menambahkan akun {phone} ke database\")\n\n                except Exception as e:\n                    logging.error(f\"Gagal mengimpor akun {account.get('phone', 'unknown')}: {str(e)}\")\n                    print(f\"Gagal mengimpor akun {account.get('phone', 'unknown')}: {str(e)}\")\n                    fail_count += 1\n\n            accounts_after = self.db_manager.count_accounts()\n            actual_added = accounts_after - accounts_before\n\n            print(f\"\\nRingkasan import dari {filename}:\")\n            print(f\"Total akun dalam file: {len(accounts)}\")\n            print(f\"Berhasil diimpor: {success_count}\")\n            print(f\"Gagal diimpor: {fail_count}\")\n            print(f\"Dilewati (duplikat): {skip_count}\")\n            print(f\"Tambahan akun di database: {actual_added}\")\n            print(f\"\\nTotal akun dalam database: {accounts_after}\")\n\n        except Exception as e:\n            logging.error(f\"Gagal mengimpor akun: {str(e)}\")\n            print(f\"Gagal mengimpor akun: {str(e)}\")", "ui\\analytics.py": "# ui/analytics.py\nimport asyncio\nimport logging\nimport json\nfrom datetime import datetime\n\nfrom aioconsole import ainput\n\nclass AnalyticsMenu:\n    def __init__(self, db_manager, client_manager):\n        self.db_manager = db_manager\n        self.client_manager = client_manager\n\n    async def export_analytics_menu(self):\n        \"\"\"UI for export analytics menu\"\"\"\n        while True:\n            print(\"\\nExport Analytics Menu\")\n            print(\"1. Export Daily Analytics\")\n            print(\"2. Export Weekly Analytics\")\n            print(\"3. Export Monthly Analytics\")\n            print(\"4. Kembali ke Menu Utama\")\n            choice = await ainput(\"Pilih menu: \")\n            if choice == '1':\n                await self.export_daily_analytics()\n            elif choice == '2':\n                await self.export_weekly_analytics()\n            elif choice == '3':\n                await self.export_monthly_analytics()\n            elif choice == '4':\n                break\n            else:\n                print(\"Pilihan tidak valid!\")\n\n    async def export_daily_analytics(self):\n        \"\"\"Export daily analytics data to a JSON file\"\"\"\n        today = datetime.now().strftime('%Y-%m-%d')\n        analytics = {\n            \"date\": today,\n            \"total_accounts\": len(self.db_manager.get_all_accounts()),\n            \"active_clients\": len(self.client_manager.active_clients)\n        }\n        filename = await ainput(\"Masukkan nama file untuk daily analytics (default: daily_analytics.json): \")\n        if not filename.strip():\n            filename = \"daily_analytics.json\"\n        try:\n            with open(filename, 'w') as f:\n                json.dump(analytics, f, indent=4)\n            print(f\"Daily analytics berhasil diekspor ke {filename}.\")\n        except Exception as e:\n            logging.error(f\"Gagal mengekspor daily analytics: {str(e)}\")\n            print(f\"Gagal mengekspor daily analytics: {str(e)}\")\n\n    async def export_weekly_analytics(self):\n        \"\"\"Export weekly analytics data to a JSON file\"\"\"\n        current_week = datetime.now().isocalendar()[1]\n        analytics = {\n            \"week\": current_week,\n            \"total_accounts\": len(self.db_manager.get_all_accounts()),\n            \"active_clients\": len(self.client_manager.active_clients)\n        }\n        filename = await ainput(\"Masukkan nama file untuk weekly analytics (default: weekly_analytics.json): \")\n        if not filename.strip():\n            filename = \"weekly_analytics.json\"\n        try:\n            with open(filename, 'w') as f:\n                json.dump(analytics, f, indent=4)\n            print(f\"Weekly analytics berhasil diekspor ke {filename}.\")\n        except Exception as e:\n            logging.error(f\"Gagal mengekspor weekly analytics: {str(e)}\")\n            print(f\"Gagal mengekspor weekly analytics: {str(e)}\")\n\n    async def export_monthly_analytics(self):\n        \"\"\"Export monthly analytics data to a JSON file\"\"\"\n        current_month = datetime.now().strftime('%Y-%m')\n        analytics = {\n            \"month\": current_month,\n            \"total_accounts\": len(self.db_manager.get_all_accounts()),\n            \"active_clients\": len(self.client_manager.active_clients)\n        }\n        filename = await ainput(\"Masukkan nama file untuk monthly analytics (default: monthly_analytics.json): \")\n        if not filename.strip():\n            filename = \"monthly_analytics.json\"\n        try:\n            with open(filename, 'w') as f:\n                json.dump(analytics, f, indent=4)\n            print(f\"Monthly analytics berhasil diekspor ke {filename}.\")\n        except Exception as e:\n            logging.error(f\"Gagal mengekspor monthly analytics: {str(e)}\")\n            print(f\"Gagal mengekspor monthly analytics: {str(e)}\")", "ui\\auto_responder.py": "# ui/auto_responder.py\nimport asyncio\nimport logging\nimport random\n\nfrom aioconsole import ainput\n\nclass AutoResponderMenu:\n    def __init__(self, rules_manager, client_manager, message_handler, db_manager):\n        self.rules_manager = rules_manager\n        self.client_manager = client_manager\n        self.message_handler = message_handler\n        self.db_manager = db_manager\n\n    async def auto_responder_menu(self):\n        \"\"\"UI for auto responder menu\"\"\"\n        while True:\n            print(\"\\nAuto Responder Menu\")\n            print(\"1. Lihat Semua Aturan\")\n            print(\"2. Tambah Aturan Baru\")\n            print(\"3. Hapus Aturan\")\n            print(\"4. Edit Aturan\")\n            print(\"5. Tambah Respons Alternatif\")\n            print(\"6. Hapus Respons Alternatif\")\n            print(\"7. Mulai Auto Responder\")\n            print(\"8. Hentikan Auto Responder\")\n            print(\"9. Export Aturan\")\n            print(\"10. Import Aturan\")\n            print(\"11. Kembali ke Menu Utama\")\n\n            choice = await ainput(\"Pilih menu: \")\n\n            if choice == '1':\n                self.list_rules()\n            elif choice == '2':\n                await self.add_rule()\n            elif choice == '3':\n                await self.delete_rule()\n            elif choice == '4':\n                await self.edit_rule()\n            elif choice == '5':\n                await self.add_alternative_response()\n            elif choice == '6':\n                await self.delete_alternative_response()\n            elif choice == '7':\n                await self.start_responder()\n            elif choice == '8':\n                await self.stop_responder()\n            elif choice == '9':\n                await self.export_rules()\n            elif choice == '10':\n                await self.import_rules()\n            elif choice == '11':\n                break  # Keluar dari loop menu auto responder\n            else:\n                print(\"Pilihan tidak valid!\")\n\n    def list_rules(self):\n        \"\"\"List all rules with responses\"\"\"\n        rules = self.rules_manager.get_all_rules()\n        if not rules:\n            print(\"Tidak ada aturan auto responder yang tersimpan.\")\n            return\n        print(\"\\nDaftar Aturan Auto Responder:\")\n        for rule_id, rule in rules.items():\n            print(f\"ID: {rule_id}\")\n            print(f\"  Kata Kunci: {rule['keyword']}\")\n            responses = rule.get('responses', [])\n            if not responses and 'response' in rule:\n                responses = [rule['response']]\n            print(f\"  Jumlah Respons: {len(responses)}\")\n            for i, response in enumerate(responses):\n                print(f\"    [{i}] {response}\")\n            print(f\"  Hanya Private Chat: {'Ya' if rule.get('private_only', False) else 'Tidak'}\")\n            print()\n\n    async def add_rule(self):\n        \"\"\"UI for adding a new rule\"\"\"\n        keyword = await ainput(\"Masukkan kata kunci/pola: \")\n        response = await ainput(\"Masukkan pesan balasan: \")\n        private_only = await ainput(\"Hanya untuk private chat? (y/n): \")\n        success, message = self.rules_manager.add_rule(\n            keyword, response, private_only.lower() == 'y'\n        )\n        print(message)\n\n    async def delete_rule(self):\n        \"\"\"UI for deleting a rule\"\"\"\n        self.list_rules()\n        rule_id = await ainput(\"Masukkan ID aturan yang akan dihapus: \")\n        success, message = self.rules_manager.delete_rule(rule_id)\n        print(message)\n\n    async def edit_rule(self):\n        \"\"\"UI for editing a rule\"\"\"\n        self.list_rules()\n        rule_id = await ainput(\"Masukkan ID aturan yang akan diedit: \")\n        rule = self.rules_manager.get_rule(rule_id)\n        if not rule:\n            print(f\"Aturan dengan ID {rule_id} tidak ditemukan!\")\n            return\n        print(f\"\\nNilai saat ini:\")\n        print(f\"Kata Kunci: {rule['keyword']}\")\n        responses = rule.get('responses', [])\n        if not responses and 'response' in rule:\n            response_main = rule['response']\n        else:\n            response_main = responses[0] if responses else \"\"\n        print(f\"Pesan Balasan Utama: {response_main}\")\n        print(f\"Hanya Private Chat: {'Ya' if rule.get('private_only', False) else 'Tidak'}\")\n        print(\"\\nMasukkan nilai baru (kosongkan untuk menggunakan nilai saat ini):\")\n        new_keyword = await ainput(\"Kata kunci baru: \")\n        new_private_only = await ainput(\"Hanya private chat? (y/n): \")\n        private_only = None\n        if new_private_only.strip():\n            private_only = new_private_only.lower() == 'y'\n        success, message = self.rules_manager.update_rule(\n            rule_id,\n            keyword=new_keyword if new_keyword.strip() else None,\n            private_only=private_only\n        )\n        print(message)\n\n    async def add_alternative_response(self):\n        \"\"\"UI for adding alternative response to existing rule\"\"\"\n        self.list_rules()\n        rule_id = await ainput(\"Masukkan ID aturan yang akan ditambah respons alternatif: \")\n        rule = self.rules_manager.get_rule(rule_id)\n        if not rule:\n            print(f\"Aturan dengan ID {rule_id} tidak ditemukan!\")\n            return\n        new_response = await ainput(\"Masukkan respons alternatif baru: \")\n        if not new_response.strip():\n            print(\"Respons tidak boleh kosong!\")\n            return\n        success, message = self.rules_manager.update_rule(\n            rule_id,\n            response=new_response\n        )\n        print(message)\n\n    async def delete_alternative_response(self):\n        \"\"\"UI for deleting an alternative response\"\"\"\n        self.list_rules()\n        rule_id = await ainput(\"Masukkan ID aturan: \")\n        rule = self.rules_manager.get_rule(rule_id)\n        if not rule:\n            print(f\"Aturan dengan ID {rule_id} tidak ditemukan!\")\n            return\n        responses = rule.get('responses', [])\n        if not responses and 'response' in rule:\n            print(\"Aturan ini menggunakan format lama dan tidak mendukung multiple responses.\")\n            return\n        if len(responses) <= 1:\n            print(\"Aturan harus memiliki minimal satu respons! Hapus aturan jika tidak diperlukan.\")\n            return\n        try:\n            response_index = int(await ainput(f\"Masukkan indeks respons yang akan dihapus (0-{len(responses)-1}): \"))\n            success, message = self.rules_manager.delete_response(rule_id, response_index)\n            print(message)\n        except ValueError:\n            print(\"Indeks respons harus berupa angka!\")\n\n    async def start_responder(self):\n        \"\"\"UI for starting an auto responder with various options\"\"\"\n        if not self.rules_manager.get_all_rules():\n            print(\"Tidak ada aturan auto responder yang tersimpan. Tambahkan aturan terlebih dahulu.\")\n            return\n        accounts = self.db_manager.get_all_accounts()\n        if not accounts:\n            print(\"Tidak ada akun yang tersimpan.\")\n            return\n        print(\"\\nPilih opsi untuk auto responder:\")\n        print(\"1. Pilih akun spesifik\")\n        print(\"2. Mulai semua akun\")\n        print(\"3. Random 5 akun\")\n        print(\"4. Random 10 akun\")\n        print(\"5. Random 20 akun\")\n        print(\"6. Masukkan jumlah akun random\")\n        option_choice = await ainput(\"Pilih opsi: \")\n        selected_accounts = []\n        try:\n            option = int(option_choice)\n            if option == 1:\n                print(\"\\nPilih akun untuk auto responder:\")\n                for i, account in enumerate(accounts, 1):\n                    print(f\"{i}. {account[2]} ({account[6] if account[6] else 'Tidak ada nama'})\")\n                account_choice = await ainput(\"Pilih nomor akun: \")\n                try:  # Tambahkan blok try-except\n                    account_index = int(account_choice) - 1\n                    if account_index < 0 or account_index >= len(accounts):\n                        print(\"Pilihan tidak valid!\")\n                        return\n                    selected_accounts = [accounts[account_index]]\n                except ValueError:  # Tangkap kesalahan ValueError\n                    print(\"Input harus berupa angka!\")\n                    return\n            elif option == 2:\n                selected_accounts = accounts\n            elif option in [3, 4, 5]:\n                num_accounts = {3: 5, 4: 10, 5: 20}.get(option)\n                if len(accounts) <= num_accounts:\n                    selected_accounts = accounts\n                else:\n                    selected_accounts = random.sample(accounts, num_accounts)\n            elif option == 6:\n                num_random = await ainput(\"Masukkan jumlah akun random: \")\n                try:\n                    num_random = int(num_random)\n                    if num_random <= 0:\n                        print(\"Jumlah akun harus lebih dari 0!\")\n                        return\n                    if len(accounts) <= num_random:\n                        selected_accounts = accounts\n                    else:\n                        selected_accounts = random.sample(accounts, num_random)\n                except ValueError:\n                    print(\"Input harus berupa angka!\")\n                    return\n            else:\n                print(\"Pilihan tidak valid!\")\n                return\n            print(\"\\nPengaturan waktu respons:\")\n            delay_config = await ainput(\"Total waktu respons (dalam menit, misalnya 120 untuk 2 jam): \")\n            try:\n                delay_minutes = float(delay_config)\n                if delay_minutes <= 0:\n                    print(\"Waktu respons minimal 1 menit!\")\n                    return\n                total_delay_seconds = delay_minutes * 60\n                print(f\"\\nMenyiapkan {len(selected_accounts)} akun dengan estimasi waktu respons {delay_minutes} menit\")\n                activated_count = 0\n                for account in selected_accounts:\n                    api_id, api_hash, phone = account[0], account[1], account[2]\n                    if phone in self.client_manager.active_clients:\n                        print(f\"Auto responder untuk {phone} sudah berjalan!\")\n                        continue\n                    client = await self.client_manager.create_client(api_id, api_hash, phone)\n                    if not await client.is_user_authorized():\n                        print(f\"Akun {phone} belum diotorisasi. Silakan login terlebih dahulu.\")\n                        await client.disconnect()\n                        continue\n                    variation = random.uniform(0.8, 1.2)\n                    account_delay = total_delay_seconds / len(selected_accounts) * variation\n                    self.message_handler.setup_handler(client, phone, account_delay)\n                    self.client_manager.add_active_client(phone, client)\n                    activated_count += 1\n                    await asyncio.sleep(0.2)\n                if activated_count > 0:\n                    print(f\"\\n{activated_count} akun berhasil diaktifkan!\")\n                    print(f\"Estimasi waktu respons: {delay_minutes} menit ({delay_minutes/60:.1f} jam)\")\n                    print(\"Setiap akun akan merespons dengan delay yang berbeda untuk pola lebih natural\")\n                else:\n                    print(\"Tidak ada akun yang berhasil diaktifkan.\")\n            except ValueError:\n                print(\"Input waktu harus berupa angka!\")\n                return\n        except ValueError:\n            print(\"Input harus berupa angka!\")\n        except Exception as e:\n            logging.error(f\"Gagal memulai auto responder: {str(e)}\")\n            print(f\"Gagal memulai auto responder: {str(e)}\")\n\n    async def stop_responder(self):\n        \"\"\"UI for stopping an auto responder\"\"\"\n        active_clients = self.client_manager.active_clients\n        if not active_clients:\n            print(\"Tidak ada auto responder yang aktif!\")\n            return\n        print(\"\\nDaftar auto responder yang aktif:\")\n        for i, phone in enumerate(active_clients.keys(), 1):\n            print(f\"{i}. {phone}\")\n        choice = await ainput(\"Pilih nomor auto responder yang akan dihentikan (0 untuk semua): \")\n        try:\n            if choice == '0':\n                for phone in list(active_clients.keys()):\n                    await self.client_manager.disconnect_client(phone)\n                    self.message_handler.remove_handler(phone)\n                print(\"Semua auto responder berhasil dihentikan!\")\n            else:\n                choice_idx = int(choice) - 1\n                if choice_idx < 0 or choice_idx >= len(active_clients):\n                    print(\"Pilihan tidak valid!\")\n                    return\n                phone = list(active_clients.keys())[choice_idx]\n                await self.client_manager.disconnect_client(phone)\n                self.message_handler.remove_handler(phone)\n                print(f\"Auto responder untuk {phone} berhasil dihentikan!\")\n        except ValueError:\n            print(\"Input harus berupa angka!\")\n        except Exception as e:\n            logging.error(f\"Gagal menghentikan auto responder: {str(e)}\")\n            print(f\"Gagal menghentikan auto responder: {str(e)}\")\n\n    async def export_rules(self):\n        \"\"\"UI for exporting rules\"\"\"\n        filename = await ainput(\"Masukkan nama file (default: responder_rules_export.json): \")\n        if not filename.strip():\n            filename = \"responder_rules_export.json\"\n        success, message = self.rules_manager.export_rules(filename)\n        print(message)\n\n    async def import_rules(self):\n        \"\"\"UI for importing rules\"\"\"\n        filename = await ainput(\"Masukkan nama file (default: responder_rules_export.json): \")\n        if not filename.strip():\n            filename = \"responder_rules_export.json\"\n        action = await ainput(\"Ganti aturan yang ada atau gabungkan? (g/m): \")\n        replace = action.lower() == 'g'\n        success, message = self.rules_manager.import_rules(filename, replace)\n        print(message)", "ui\\main_menu.py": "# ui/main_menu.py\nimport asyncio\nimport logging\n\nfrom aioconsole import ainput\n\nclass MainMenu:\n    def __init__(self, account_manager, auto_responder_menu, task_scheduling_menu,\n                 work_cycle_menu, analytics_menu, status_menu):\n        self.account_manager = account_manager\n        self.auto_responder_menu = auto_responder_menu\n        self.task_scheduling_menu = task_scheduling_menu\n        self.work_cycle_menu = work_cycle_menu\n        self.analytics_menu = analytics_menu\n        self.status_menu = status_menu\n\n    async def display_main_menu(self):\n        \"\"\"Display main menu and handle user choices\"\"\"\n        while True:\n            print(\"\\nTelethon Unlimited Login System\")\n            print(\"1. Tambah Akun\")\n            print(\"2. Lihat Semua Akun\")\n            print(\"3. Uji Koneksi\")\n            print(\"4. Hapus Akun\")\n            print(\"5. Auto Responder\")\n            print(\"6. Update Akun\")\n            print(\"7. Export Akun\")\n            print(\"8. Import Akun\")\n            print(\"9. Task Scheduling Menu\")\n            print(\"10. Daily Work Cycle Menu\")\n            print(\"11. Export Analytics Menu\")\n            print(\"12. Status and Statistics Menu\")\n            print(\"13. Keluar\")\n\n            choice = await ainput(\"Pilih menu: \")\n\n            if choice == '1':\n                await self.account_manager.add_account()\n            elif choice == '2':\n                self.account_manager.list_accounts()\n            elif choice == '3':\n                await self.account_manager.test_connection()\n            elif choice == '4':\n                await self.account_manager.delete_account()\n            elif choice == '5':\n                await self.auto_responder_menu.auto_responder_menu()\n            elif choice == '6':\n                await self.account_manager.update_account()\n            elif choice == '7':\n                await self.account_manager.export_accounts()\n            elif choice == '8':\n                await self.account_manager.import_accounts()\n            elif choice == '9':\n                await self.task_scheduling_menu.task_scheduling_menu()\n            elif choice == '10':\n                await self.work_cycle_menu.daily_work_cycle_menu()\n            elif choice == '11':\n                await self.analytics_menu.export_analytics_menu()\n            elif choice == '12':\n                await self.status_menu.status_and_stats_menu()\n            elif choice == '13':\n                break\n            else:\n                print(\"Pilihan tidak valid!\")", "ui\\status.py": "# ui/status.py\nimport asyncio\nimport logging\nfrom datetime import datetime\n\nfrom aioconsole import ainput\nfrom prettytable import PrettyTable\n\nclass StatusMenu:  # Pastikan nama kelasnya StatusMenu\n    def __init__(self, db_manager, client_manager):\n        self.db_manager = db_manager\n        self.client_manager = client_manager\n        self.start_time = datetime.now()\n\n    async def status_and_stats_menu(self):\n        \"\"\"UI for status and statistics menu\"\"\"\n        while True:\n            print(\"\\nStatus and Statistics Menu\")\n            print(\"1. View System Status\")\n            print(\"2. View Account Statistics\")\n            print(\"3. Kembali ke Menu Utama\")\n            choice = await ainput(\"Pilih menu: \")\n            if choice == '1':\n                await self.view_system_status()\n            elif choice == '2':\n                await self.view_account_statistics()\n            elif choice == '3':\n                break\n            else:\n                print(\"Pilihan tidak valid!\")\n\n    async def view_system_status(self):\n        \"\"\"Display system status including uptime and active components\"\"\"\n        uptime = datetime.now() - self.start_time\n        total_accounts = len(self.db_manager.get_all_accounts())\n        active_clients = len(self.client_manager.active_clients)\n        print(\"\\n--- System Status ---\")\n        print(f\"Uptime: {str(uptime).split('.')[0]}\")\n        print(f\"Total Accounts: {total_accounts}\")\n        print(f\"Active Clients: {active_clients}\")\n\n    async def view_account_statistics(self):\n        \"\"\"Display account statistics using a table\"\"\"\n        accounts = self.db_manager.get_all_accounts()\n        if not accounts:\n            print(\"Tidak ada data akun untuk ditampilkan.\")\n            return\n        table = PrettyTable()\n        table.field_names = [\"API ID\", \"Phone\", \"User ID\", \"Username\", \"Name\"]\n        for row in accounts:\n            table.add_row([row[0], row[2], row[4], row[5], row[6]])\n        print(\"\\n--- Account Statistics ---\")\n        print(table)", "ui\\task_scheduling.py": "# ui/task_scheduling.py\nimport asyncio\nimport logging\nfrom datetime import datetime\n\nfrom aioconsole import ainput\nfrom prettytable import PrettyTable\n\nclass TaskSchedulingMenu:\n    def __init__(self):\n        self.scheduled_tasks = {}  # task_id -> task_info dict\n        self.task_id_counter = 1\n\n    async def task_scheduling_menu(self):\n        \"\"\"UI for task scheduling menu\"\"\"\n        while True:\n            print(\"\\nTask Scheduling Menu\")\n            print(\"1. Add Task\")\n            print(\"2. List Tasks\")\n            print(\"3. Delete Task\")\n            print(\"4. Kembali ke Menu Utama\")\n            choice = await ainput(\"Pilih menu: \")\n            if choice == '1':\n                await self.add_task()\n            elif choice == '2':\n                await self.list_tasks()\n            elif choice == '3':\n                await self.delete_task()\n            elif choice == '4':\n                break\n            else:\n                print(\"Pilihan tidak valid!\")\n\n    async def add_task(self):\n        \"\"\"Add a new task with scheduled execution\"\"\"\n        task_name = await ainput(\"Masukkan nama tugas: \")\n        task_command = await ainput(\"Masukkan deskripsi/command tugas: \")\n        delay_minutes = await ainput(\"Jadwalkan tugas dalam berapa menit dari sekarang: \")\n        try:\n            delay = float(delay_minutes) * 60  # convert to seconds\n            execute_at = datetime.now() + datetime.timedelta(seconds=delay)\n            task_id = self.task_id_counter\n            self.task_id_counter += 1\n\n            task_future = asyncio.create_task(self._run_task(task_id))\n            self.scheduled_tasks[task_id] = {\n                \"name\": task_name,\n                \"command\": task_command,\n                \"execute_at\": execute_at,\n                \"future\": task_future,\n                \"executed\": False\n            }\n            print(f\"Tugas '{task_name}' dijadwalkan pada {execute_at.strftime('%Y-%m-%d %H:%M:%S')} dengan ID {task_id}.\")\n        except ValueError:\n            print(\"Input waktu tidak valid!\")\n\n    async def _run_task(self, task_id):\n        \"\"\"Internal: Wait until the task's scheduled time, then execute the task\"\"\"\n        task_info = self.scheduled_tasks.get(task_id)\n        if not task_info:\n            return\n        now = datetime.now()\n        delay = (task_info[\"execute_at\"] - now).total_seconds()\n        if delay > 0:\n            await asyncio.sleep(delay)\n        print(f\"\\n[TASK EXECUTED] Tugas '{task_info['name']}' dengan command: {task_info['command']} telah dijalankan pada {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")\n        task_info[\"executed\"] = True\n\n    async def list_tasks(self):\n        \"\"\"List all scheduled tasks\"\"\"\n        if not self.scheduled_tasks:\n            print(\"Tidak ada tugas yang dijadwalkan.\")\n            return\n        table = PrettyTable()\n        table.field_names = [\"Task ID\", \"Nama Tugas\", \"Execute At\", \"Status\"]\n        for task_id, info in self.scheduled_tasks.items():\n            status = \"Sudah dieksekusi\" if info.get(\"executed\", False) else \"Belum dieksekusi\"\n            table.add_row([task_id, info[\"name\"], info[\"execute_at\"].strftime('%Y-%m-%d %H:%M:%S'), status])\n        print(table)\n\n    async def delete_task(self):\n        \"\"\"Delete a scheduled task\"\"\"\n        task_id_input = await ainput(\"Masukkan ID tugas yang akan dihapus: \")\n        try:\n            task_id = int(task_id_input)\n            if task_id in self.scheduled_tasks:\n                task_info = self.scheduled_tasks.pop(task_id)\n                future = task_info.get(\"future\")\n                if future and not future.done():\n                    future.cancel()\n                print(f\"Tugas dengan ID {task_id} berhasil dihapus.\")\n            else:\n                print(\"Tugas tidak ditemukan.\")\n        except ValueError:\n            print(\"Input harus berupa angka!\")", "ui\\work_cycle.py": "# ui/work_cycle.py\nimport asyncio\nimport logging\nfrom datetime import datetime\n\nfrom aioconsole import ainput\n\nclass WorkCycleMenu:\n    def __init__(self):\n        self.work_cycle_task = None\n        self.work_cycle_iteration = 0\n\n    async def daily_work_cycle_menu(self):\n        \"\"\"UI for daily work cycle menu\"\"\"\n        while True:\n            print(\"\\nDaily Work Cycle Menu\")\n            print(\"1. Start Work Cycle\")\n            print(\"2. Stop Work Cycle\")\n            print(\"3. View Cycle Status\")\n            print(\"4. Kembali ke Menu Utama\")\n            choice = await ainput(\"Pilih menu: \")\n            if choice == '1':\n                await self.start_work_cycle()\n            elif choice == '2':\n                await self.stop_work_cycle()\n            elif choice == '3':\n                await self.view_cycle_status()\n            elif choice == '4':\n                break\n            else:\n                print(\"Pilihan tidak valid!\")\n\n    async def start_work_cycle(self):\n        \"\"\"Start daily work cycle with periodic task execution\"\"\"\n        if self.work_cycle_task and not self.work_cycle_task.done():\n            print(\"Daily work cycle sudah berjalan.\")\n            return\n        async def work_cycle():\n            while True:\n                self.work_cycle_iteration += 1\n                print(f\"[WORK CYCLE] Iterasi {self.work_cycle_iteration} pada {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")\n                await asyncio.sleep(10)\n        self.work_cycle_task = asyncio.create_task(work_cycle())\n        print(\"Daily work cycle dimulai.\")\n\n    async def stop_work_cycle(self):\n        \"\"\"Stop the daily work cycle if running\"\"\"\n        if self.work_cycle_task and not self.work_cycle_task.done():\n            self.work_cycle_task.cancel()\n            try:\n                await self.work_cycle_task\n            except asyncio.CancelledError:\n                pass\n            print(\"Daily work cycle dihentikan.\")\n        else:\n            print(\"Daily work cycle tidak berjalan.\")\n\n    async def view_cycle_status(self):\n        \"\"\"Display current status of the daily work cycle\"\"\"\n        if self.work_cycle_task and not self.work_cycle_task.done():\n            print(f\"Daily work cycle berjalan. Iterasi terakhir: {self.work_cycle_iteration}\")\n        else:\n            print(\"Daily work cycle tidak berjalan.\")", "ui\\__init__.py": "# ui/__init__.py\nfrom .main_menu import MainMenu\nfrom .account_management import AccountManagement\nfrom .auto_responder import AutoResponderMenu\nfrom .task_scheduling import TaskSchedulingMenu\nfrom .work_cycle import WorkCycleMenu\nfrom .analytics import AnalyticsMenu\nfrom .status import StatusMenu", "utils\\helpers.py": "# utils/helpers.py\nimport os\nimport logging\nfrom datetime import datetime\n\ndef setup_logging():\n    \"\"\"Mengatur konfigurasi logging.\"\"\"\n    os.makedirs('logs', exist_ok=True)\n    log_file = f\"logs/{datetime.now().strftime('%Y-%m-%d')}.log\"\n    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s',\n                        handlers=[logging.FileHandler(log_file), logging.StreamHandler()])", "utils\\__init__.py": "# utils/__init__.py\nfrom .helpers import setup_logging"}}